# Story 2.1: Database & Redis Setup

## Status

Draft

## Story

**As a** System,
**I want** PostgreSQL and Redis deployed on Railway with Prisma ORM configured,
**so that** I can persist project data, enable background job processing, and support real-time pub/sub.

## Acceptance Criteria

1. Prisma schema created with Project, Artifact, WebhookEvent, MCPAuditLog models
2. Initial migration generated and applied locally
3. Railway Postgres provisioned and connected
4. Railway Redis provisioned and connected
5. Prisma Client generated with TypeScript types
6. Database connection tested with health check query
7. Redis pub/sub tested with sample publish/subscribe
8. Environment variables configured (`.env.example` updated)
9. Database seed script created (optional - for testing)
10. All tests pass (`pnpm test`)

## Tasks / Subtasks

- [ ] **Task 1: Install Database Dependencies** (AC: 1, 5)
  - [ ] Install Prisma CLI: `pnpm add -D prisma`
  - [ ] Install Prisma Client: `pnpm add @prisma/client`
  - [ ] Install Redis client: `pnpm add ioredis`
  - [ ] Install types: `pnpm add -D @types/ioredis`
  - [ ] Verify package.json includes all dependencies
  - [ ] Run `pnpm type-check` to ensure no errors

- [ ] **Task 2: Initialize Prisma** (AC: 1)
  - [ ] Run `npx prisma init` to create `prisma/` directory
  - [ ] Verify `prisma/schema.prisma` created
  - [ ] Update datasource to use PostgreSQL provider
  - [ ] Set `DATABASE_URL` in `.env.local` (placeholder for local dev)
  - [ ] Configure Prisma generator for TypeScript client

- [ ] **Task 3: Create Prisma Schema** (AC: 1)
  - [ ] Open `prisma/schema.prisma`
  - [ ] Define `Project` model (id, name, repoUrl, webhookSecret, config, timestamps)
  - [ ] Define `Artifact` model (id, projectId, path, name, type, version, timestamps)
  - [ ] Define `WebhookEvent` model (id, source, projectId, eventType, payloadHash, processed, timestamps)
  - [ ] Define `MCPAuditLog` model (id, projectId, actor fields, tool, scope, result, timestamp, IP, userAgent)
  - [ ] Define enums: `WebhookSource`, `ArtifactType`, `MCPResult`
  - [ ] Add relations: Project has many Artifacts, WebhookEvents, MCPAuditLogs
  - [ ] Add indexes: `@@unique([projectId, path])` on Artifact, `@@index([projectId, processed])` on WebhookEvent
  - [ ] Verify schema matches architecture data models (docs/architecture.md lines 1222-1451)

- [ ] **Task 4: Generate Initial Migration** (AC: 2)
  - [ ] Run `npx prisma migrate dev --name init` locally
  - [ ] Verify `prisma/migrations/<timestamp>_init/` directory created
  - [ ] Review generated SQL in `migration.sql`
  - [ ] Verify tables created in local Postgres (use Docker or install locally)
  - [ ] Run `npx prisma studio` to inspect database visually (optional)

- [ ] **Task 5: Provision Railway Postgres** (AC: 3)
  - [ ] Log in to Railway dashboard
  - [ ] Navigate to JIVE project
  - [ ] Click "New" → "Database" → "PostgreSQL"
  - [ ] Railway auto-provisions Postgres and injects `DATABASE_URL` env variable
  - [ ] Copy `DATABASE_URL` from Railway to `.env.local` for local testing
  - [ ] Run `npx prisma migrate deploy` to apply migrations to Railway Postgres
  - [ ] Verify tables created in Railway Postgres (use Railway's database UI or `psql`)

- [ ] **Task 6: Provision Railway Redis** (AC: 4)
  - [ ] In Railway dashboard, click "New" → "Database" → "Redis"
  - [ ] Railway auto-provisions Redis and injects `REDIS_URL` env variable
  - [ ] Copy `REDIS_URL` from Railway to `.env.local`
  - [ ] Verify Redis connection via Railway CLI: `railway run redis-cli ping`

- [ ] **Task 7: Create Prisma Client Singleton** (AC: 5, 6)
  - [ ] Create `lib/db/prisma.ts` file
  - [ ] Import `PrismaClient` from `@prisma/client`
  - [ ] Implement singleton pattern:

    ```typescript
    import { PrismaClient } from '@prisma/client';

    const globalForPrisma = global as unknown as { prisma: PrismaClient };

    export const prisma = globalForPrisma.prisma || new PrismaClient();

    if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;
    ```

  - [ ] Add health check function: `async function testConnection()`
  - [ ] Call `prisma.$queryRaw\`SELECT 1\`` to test connection
  - [ ] Export `prisma` singleton and `testConnection` function

- [ ] **Task 8: Create Redis Client Singleton** (AC: 4, 7)
  - [ ] Create `lib/db/redis.ts` file
  - [ ] Import `Redis` from `ioredis`
  - [ ] Create Redis client singleton:

    ```typescript
    import Redis from 'ioredis';

    const redisUrl = process.env.REDIS_URL || 'redis://localhost:6379';
    export const redis = new Redis(redisUrl);
    ```

  - [ ] Add pub/sub helper functions:
    - `publishEvent(channel, data)`
    - `subscribeToChannel(channel, handler)`
  - [ ] Add error handling for connection failures

- [ ] **Task 9: Update Environment Variables** (AC: 8)
  - [ ] Open `.env.example`
  - [ ] Add `DATABASE_URL=postgresql://user:password@localhost:5432/jive_dev`
  - [ ] Add `REDIS_URL=redis://localhost:6379`
  - [ ] Add comments explaining Railway auto-injects these in production
  - [ ] Update README.md with database setup instructions:
    - Local: Install Postgres/Redis or use Docker
    - Staging/Production: Railway provisions automatically

- [ ] **Task 10: Create Database Seed Script** (AC: 9 - Optional)
  - [ ] Create `prisma/seed.ts` file
  - [ ] Import Prisma client
  - [ ] Create sample project:
    ```typescript
    await prisma.project.create({
      data: {
        name: 'JIVE',
        repoUrl: 'https://github.com/example/jive',
        webhookSecret: 'test-secret',
        config: { prdFile: 'docs/prd.md', ... },
      },
    });
    ```
  - [ ] Add `prisma.seed` script to package.json:
    ```json
    "prisma": {
      "seed": "tsx prisma/seed.ts"
    }
    ```
  - [ ] Run `npx prisma db seed` to test seeding

- [ ] **Task 11: Write Integration Tests** (AC: 6, 7, 10)
  - [ ] Create `tests/integration/db/prisma.test.ts`
  - [ ] Write test: `connects to database successfully`
    - [ ] Import `prisma` client
    - [ ] Call `prisma.$queryRaw\`SELECT 1\``
    - [ ] Assert query succeeds
  - [ ] Write test: `creates and retrieves project`
    - [ ] Create test project with `prisma.project.create()`
    - [ ] Retrieve with `prisma.project.findUnique()`
    - [ ] Assert project data matches
    - [ ] Cleanup: `prisma.project.delete()`
  - [ ] Create `tests/integration/db/redis.test.ts`
  - [ ] Write test: `publishes and subscribes to channel`
    - [ ] Subscribe to test channel
    - [ ] Publish message
    - [ ] Assert subscriber receives message
    - [ ] Unsubscribe and cleanup
  - [ ] Run `pnpm test` (note: integration tests skipped by default per vitest.config.mts)
  - [ ] Run `pnpm test tests/integration/db/` to run integration tests explicitly

- [ ] **Task 12: Update Health Endpoint** (AC: 6)
  - [ ] Open `app/api/health/route.ts`
  - [ ] Import `prisma` from `@/lib/db/prisma`
  - [ ] Add database health check:
    ```typescript
    const dbHealthy = await prisma.$queryRaw`SELECT 1`
      .then(() => true)
      .catch(() => false);
    ```
  - [ ] Update response to include `database: dbHealthy` field
  - [ ] Test health endpoint: `curl http://localhost:3000/api/health`
  - [ ] Verify `database: true` in response

- [ ] **Task 13: Verify Build and Deployment** (AC: 10)
  - [ ] Run `npx prisma generate` to regenerate Prisma Client
  - [ ] Run `pnpm type-check` to verify no TypeScript errors
  - [ ] Run `pnpm lint` to verify no linting errors
  - [ ] Run `pnpm build` to verify production build succeeds
  - [ ] Verify Railway deployment: Push to staging branch
  - [ ] Check Railway logs for successful migration and connection
  - [ ] Test health endpoint on Railway: `curl https://jive-staging.up.railway.app/api/health`
  - [ ] Verify `database: true` in response

## Dev Notes

### Previous Story Insights

**[From Story 1.4 Dev Agent Record]**

Key learnings from previous stories:

1. **Railway Deployment:** Stories 1.1-1.2 established Railway deployment pipeline. Story 2.1 adds Postgres/Redis add-ons via Railway dashboard.

2. **Environment Variables:** `.env.example` pattern established. Story 2.1 adds `DATABASE_URL` and `REDIS_URL`.

3. **TypeScript Strict Mode:** All code must use explicit types. Prisma Client auto-generates types, eliminating manual type definitions.

4. **Integration Tests:** Vitest config (updated) excludes integration tests by default. Run explicitly with `pnpm test tests/integration/`.

### Architecture Context

**[Source: docs/architecture.md#tech-stack]**

#### Database & ORM (lines 257-259)

**Database:** PostgreSQL 14+ (Railway managed)

**ORM:** Prisma 5+ for type-safe queries and migrations

**Rationale:**

- Auto-generated TypeScript types from schema
- Migrations with version control
- Query builder prevents SQL injection
- Excellent TypeScript support

**Connection:** PgBouncer connection pooling (Railway managed)

**[Source: docs/architecture.md#database-schema]**

#### Prisma Schema (lines 1222-1451)

**Core Tables for Story 2.1:**

```prisma
model Project {
  id            String      @id @default(uuid())
  name          String
  repoUrl       String      @unique
  webhookSecret String      @db.Text // Encrypted at rest
  config        Json        // ProjectConfig as JSONB
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  lastSeen      DateTime    @default(now())

  artifacts     Artifact[]
  webhookEvents WebhookEvent[]
  mcpAuditLogs  MCPAuditLog[]

  @@index([repoUrl])
}

model Artifact {
  id          String    @id @default(uuid())
  projectId   String
  path        String
  name        String
  type        ArtifactType
  version     String?
  createdBy   String?
  createdAt   DateTime?
  updatedAt   DateTime  @updatedAt
  dependencies Json     // Array of {path, version}
  content     String?   @db.Text

  project     Project   @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@unique([projectId, path])
  @@index([projectId, type])
  @@index([projectId, updatedAt])
}

model WebhookEvent {
  id           String        @id
  source       WebhookSource
  projectId    String
  eventType    String
  payloadHash  String
  processed    Boolean       @default(false)
  processedAt  DateTime?
  retryCount   Int           @default(0)
  errorMessage String?       @db.Text
  receivedAt   DateTime      @default(now())

  project      Project       @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@unique([id, source])
  @@index([projectId, processed])
  @@index([payloadHash])
}

model MCPAuditLog {
  id           String    @id @default(uuid())
  projectId    String
  actorType    String    // 'user' | 'service_account'
  actorId      String
  actorName    String
  tool         String
  scope        String
  argsHash     String    // SHA-256
  result       MCPResult
  errorMessage String?   @db.Text
  timestamp    DateTime  @default(now())
  ipAddress    String
  userAgent    String    @db.Text

  project      Project   @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([projectId, timestamp])
  @@index([actorId, timestamp])
  @@index([tool, timestamp])
}

enum ArtifactType {
  PRD
  ARCHITECTURE
  STORY
  QA
  OTHER
}

enum WebhookSource {
  GITHUB
  GITLAB
  BITBUCKET
}

enum MCPResult {
  SUCCESS
  FAILURE
  UNAUTHORIZED
  RATE_LIMITED
}
```

**Note:** Story 2.1 creates schema for core tables. Additional models (AgentStatus, Conflict, Gate, Run) will be added in Epic 3+ when those features are implemented.

**[Source: docs/architecture.md#tech-stack (line 259)]**

#### Redis & Job Queue (lines 259-260)

**Cache & Queues:** Redis 7+ (Railway managed)

**Job Queue:** BullMQ 4+ (Redis-backed queue)

**Use Cases:**

- Event queues for background jobs (artifact-scan, conflict-detection)
- Pub/sub for real-time broadcasts to WebSocket clients
- Rate limiting for MCP server (token bucket)

**[Source: docs/architecture.md#database-schema (lines 1505-1569)]**

#### Redis Data Structures

**BullMQ Job Queues:**

```typescript
// Queue: artifact-scan
{
  name: 'artifact-scan',
  data: {
    projectId: 'uuid',
    repoUrl: 'https://github.com/org/repo',
    branch: 'main'
  },
  opts: {
    attempts: 3,
    backoff: { type: 'exponential', delay: 2000 }
  }
}
```

**Pub/Sub Channels:**

```typescript
// Channel: project:{projectId}
{
  event: 'agent_status_changed' | 'artifact_updated' | 'conflict_detected',
  projectId: 'uuid',
  timestamp: '2025-10-15T15:30:00Z',
  payload: { ... }
}
```

**Rate Limiting (Token Bucket):**

```typescript
// Key: rate_limit:mcp:{clientId}:{tool}
// Value: { tokens: 60, lastRefill: timestamp }
// TTL: 60 seconds
```

### Testing Strategy

**[Source: docs/architecture.md#testing-strategy]**

**Integration Test Requirements for Story 2.1:**

- **Framework:** Vitest with test database
- **Test Isolation:** Use separate test database or cleanup after each test
- **Coverage Target:** Integration tests verify connectivity, not line coverage

**Test Categories:**

1. **Prisma Connection:** Test `SELECT 1` query succeeds
2. **CRUD Operations:** Create, read, update, delete project
3. **Relations:** Create project with webhookEvents, verify relations work
4. **Redis Pub/Sub:** Publish message, verify subscriber receives it
5. **Redis Connection:** Test `PING` command

**Test Database Setup:**

Option 1: Use Railway test database (separate from staging/production)
Option 2: Use local Postgres in Docker for CI/CD

**Example Integration Test:**

```typescript
// tests/integration/db/prisma.test.ts
import { describe, test, expect, beforeAll, afterAll } from 'vitest';
import { prisma } from '@/lib/db/prisma';

describe('Prisma Integration', () => {
  beforeAll(async () => {
    // Ensure connection
    await prisma.$connect();
  });

  afterAll(async () => {
    // Cleanup and disconnect
    await prisma.$disconnect();
  });

  test('connects to database successfully', async () => {
    const result = await prisma.$queryRaw`SELECT 1 as value`;
    expect(result).toBeDefined();
  });

  test('creates and retrieves project', async () => {
    const project = await prisma.project.create({
      data: {
        name: 'Test Project',
        repoUrl: 'https://github.com/test/repo',
        webhookSecret: 'test-secret',
        config: {
          prdFile: 'docs/prd.md',
          architectureFile: 'docs/architecture.md',
        },
      },
    });

    const retrieved = await prisma.project.findUnique({
      where: { id: project.id },
    });

    expect(retrieved?.name).toBe('Test Project');

    // Cleanup
    await prisma.project.delete({ where: { id: project.id } });
  });
});
```

### Tech Stack Additions

**New Dependencies for Story 2.1:**

| Dependency     | Version | Purpose                      | Rationale                                              |
| -------------- | ------- | ---------------------------- | ------------------------------------------------------ |
| prisma         | 5+      | Prisma CLI for migrations    | Generate migrations, manage schema, run Prisma Studio  |
| @prisma/client | 5+      | Type-safe database client    | Auto-generated from schema, provides type-safe queries |
| ioredis        | 5+      | Redis client for Node.js     | Pub/sub, rate limiting, job queues (via BullMQ)        |
| @types/ioredis | 5+      | TypeScript types for ioredis | Type safety for Redis operations                       |

**Installation Commands:**

```bash
pnpm add -D prisma
pnpm add @prisma/client ioredis
pnpm add -D @types/ioredis
```

**Note:** BullMQ will be added in Story 2.5 (Orchestrator Worker). Story 2.1 focuses on database/Redis foundation.

### File Locations

**New Files Created in Story 2.1:**

```
jive/
├── prisma/
│   ├── schema.prisma              # NEW - Prisma schema
│   ├── migrations/
│   │   └── <timestamp>_init/
│   │       └── migration.sql      # NEW - Initial migration
│   └── seed.ts                    # NEW - Database seed script (optional)
├── lib/
│   └── db/
│       ├── prisma.ts              # NEW - Prisma client singleton
│       └── redis.ts               # NEW - Redis client singleton
├── tests/
│   └── integration/
│       └── db/
│           ├── prisma.test.ts     # NEW - Prisma integration tests
│           └── redis.test.ts      # NEW - Redis integration tests
├── .env.example                   # UPDATE - Add DATABASE_URL, REDIS_URL
└── README.md                      # UPDATE - Add database setup instructions
```

### Coding Standards

**[Source: docs/architecture.md#coding-standards]**

**Critical Rules for Story 2.1:**

1. **Prisma Singleton Pattern:** Prevent multiple Prisma Client instances in development:

   ```typescript
   const globalForPrisma = global as unknown as { prisma: PrismaClient };
   export const prisma = globalForPrisma.prisma || new PrismaClient();
   ```

2. **Error Handling:** Database operations must use try-catch:

   ```typescript
   try {
     await prisma.project.create({ data });
   } catch (error) {
     console.error('Database error:', error);
     throw new Error('Failed to create project');
   }
   ```

3. **Environment Variables:** Never commit `.env.local` to git. Use `.env.example` for templates.

4. **Migration Naming:** Use descriptive names: `npx prisma migrate dev --name add_mcp_audit_logs`

5. **Type Safety:** Use Prisma-generated types:
   ```typescript
   import { Project, Artifact } from '@prisma/client';
   ```

### Deployment Strategy

**[Source: docs/architecture.md#deployment-architecture (lines 1849-1860)]**

**Railway Postgres:**

- **Version:** 14+
- **Provisioned:** 1 GB RAM (Phase 1), auto-scale Phase 2
- **Backups:** Daily automatic snapshots
- **Extensions:** pg_stat_statements, pgcrypto

**Railway Redis:**

- **Version:** 7+
- **Provisioned:** 256 MB RAM (Phase 1)
- **Persistence:** AOF enabled (append-only file)
- **Max Memory Policy:** allkeys-lru

**Migration Strategy:**

- **Development:** `prisma migrate dev` (auto-generate + apply)
- **Production:** `prisma migrate deploy` (apply only, no prompts)
- **Railway CI/CD:** Runs migrations on deploy via build command

**Example Railway Build Command (railway.json):**

```json
{
  "build": {
    "builder": "NIXPACKS",
    "buildCommand": "pnpm install && npx prisma generate && npx prisma migrate deploy && pnpm build"
  }
}
```

### Security Considerations

**[Source: docs/architecture.md#security-requirements]**

**Database Security:**

1. **Connection String Security:**
   - Never commit `DATABASE_URL` to git
   - Use Railway environment variables in production
   - Rotate credentials if exposed

2. **SQL Injection Prevention:**
   - Always use Prisma parameterized queries
   - Never use raw SQL with user input (use `$queryRawUnsafe` only for trusted queries)

3. **Row-Level Security (RLS):**
   - Deferred to later story (requires multi-tenant user context)
   - Story 2.1 creates tables without RLS policies

4. **Secrets Encryption:**
   - `webhookSecret` stored as plain text in Story 2.1
   - Add encryption in production hardening phase

**Redis Security:**

1. **Connection Security:**
   - Railway Redis uses TLS by default
   - Use `rediss://` protocol for encrypted connections

2. **Rate Limiting:**
   - Implemented in Story 2.3 (MCP Auth)
   - Story 2.1 provides Redis client foundation

### Relationship to Future Stories

**Story 2.1 Foundation for:**

- **Story 2.2 (MCP Server):** MCP server queries Prisma for project data
- **Story 2.3 (MCP Auth):** Audit logs persisted to `mcp_audit_logs` table
- **Story 2.4 (MCP Tools):** Tools query Prisma for status, conflicts, gates, runs
- **Story 2.5 (Orchestrator):** BullMQ uses Redis, orchestrator persists webhook events to `webhook_events` table
- **Epic 3 (Agent Status):** Requires `agent_status` table (added in later migration)

**Database Schema Evolution:**

Story 2.1 creates initial schema. Future stories will add migrations for:

- `agent_status` table (Epic 3)
- `conflict` table (Epic 5)
- `gate` and `run` tables (Epic 6)
- Row-Level Security policies (Phase 2)

### Performance Considerations

**Connection Pooling:**

Railway Postgres includes PgBouncer for connection pooling. No manual configuration needed in Story 2.1.

**Query Optimization:**

- Indexes defined in Prisma schema (`@@index`)
- Composite unique constraints (`@@unique([projectId, path])`)
- Cascade deletes for referential integrity (`onDelete: Cascade`)

**Redis Persistence:**

- AOF (Append-Only File) enabled for durability
- LRU eviction policy when memory limit reached
- No manual optimization needed in Story 2.1

## Change Log

| Date       | Version | Description                                   | Author |
| ---------- | ------- | --------------------------------------------- | ------ |
| 2025-10-15 | 1.0     | Story created for Epic 2 infrastructure setup | SM Bob |

## Dev Agent Record

### Agent Model Used

_To be filled by Dev Agent_

### Debug Log References

_To be filled by Dev Agent_

### Completion Notes

_To be filled by Dev Agent_

### File List

_To be filled by Dev Agent_

## QA Results

_To be filled by QA Agent after implementation_
