# Story 2.4: MCP Tool Registry & Phase 1 Tools

## Status

Draft

## Story

**As an** IDE Agent (Cursor/Codex),
**I want** to discover and invoke JIVE tools via Model Context Protocol,
**so that** I can query project status, manage tasks, and access quality gates from my IDE.

## Acceptance Criteria

1. Tool discovery endpoint `GET /mcp/tools` returns tool schemas (OpenAPI-like format)
2. Tool invocation endpoint `POST /mcp/invoke` dispatches to registered tool handlers
3. Tool registry pattern implemented (decorator or registry class)
4. Phase 1 tools implemented (5 tools):
   - `status.get(project_id)` → Returns agent statuses
   - `conflicts.list(project_id)` → Returns active conflicts
   - `kanban.moveStory(project_id, story_id, lane)` → Updates story status
   - `gates.list(project_id)` → Returns quality gate statuses
   - `runs.list(project_id, filters)` → Returns agent execution runs
5. Each tool queries Prisma for data (no hardcoded responses)
6. Each tool logs to `mcp_audit_logs` table
7. Integration tests for all 5 tools with mocked Prisma data
8. Postman/curl examples documented for manual testing
9. All tests pass (`pnpm test`)

## Tasks / Subtasks

- [ ] **Task 1: Define Tool Schema Types** (AC: 1, 2)
  - [ ] Create `lib/mcp/types/tool.ts` file
  - [ ] Define `MCPToolSchema` interface:

    ```typescript
    export interface MCPToolParameter {
      name: string;
      type: 'string' | 'number' | 'boolean' | 'object' | 'array';
      description: string;
      required: boolean;
      schema?: any; // JSON Schema for complex types
    }

    export interface MCPToolSchema {
      name: string;
      description: string;
      scope: string; // Required scope to invoke this tool
      parameters: MCPToolParameter[];
      returns: {
        type: string;
        description: string;
        schema?: any;
      };
    }

    export interface MCPToolInvocation {
      tool: string;
      projectId: string;
      args: Record<string, any>;
    }

    export interface MCPToolResult<T = any> {
      success: boolean;
      data?: T;
      error?: {
        code: string;
        message: string;
      };
    }
    ```

  - [ ] Export all types

- [ ] **Task 2: Create Tool Registry** (AC: 3)
  - [ ] Create `lib/mcp/tool-registry.ts` file
  - [ ] Define `MCPToolHandler` type:

    ```typescript
    import { MCPTokenPayload } from './types/jwt';
    import { MCPToolResult } from './types/tool';

    export type MCPToolHandler<T = any> = (
      args: Record<string, any>,
      token: MCPTokenPayload,
      projectId: string,
    ) => Promise<MCPToolResult<T>>;
    ```

  - [ ] Create `ToolRegistry` class:

    ```typescript
    export class ToolRegistry {
      private tools: Map<
        string,
        {
          schema: MCPToolSchema;
          handler: MCPToolHandler;
        }
      > = new Map();

      register(schema: MCPToolSchema, handler: MCPToolHandler): void {
        this.tools.set(schema.name, { schema, handler });
      }

      get(name: string) {
        return this.tools.get(name);
      }

      getAll(): MCPToolSchema[] {
        return Array.from(this.tools.values()).map((t) => t.schema);
      }

      async invoke(
        toolName: string,
        args: Record<string, any>,
        token: MCPTokenPayload,
        projectId: string,
      ): Promise<MCPToolResult> {
        const tool = this.tools.get(toolName);
        if (!tool) {
          return {
            success: false,
            error: {
              code: 'TOOL_NOT_FOUND',
              message: `Tool '${toolName}' not found`,
            },
          };
        }

        try {
          return await tool.handler(args, token, projectId);
        } catch (error) {
          return {
            success: false,
            error: {
              code: 'TOOL_EXECUTION_ERROR',
              message: error instanceof Error ? error.message : 'Unknown error',
            },
          };
        }
      }
    }

    export const toolRegistry = new ToolRegistry();
    ```

  - [ ] Export `toolRegistry` singleton

- [ ] **Task 3: Implement `status.get` Tool** (AC: 4, 5, 6)
  - [ ] Create `lib/mcp/tools/status.ts` file
  - [ ] Define tool schema:

    ```typescript
    import { MCPToolSchema } from '../types/tool';
    import { MCP_SCOPES } from '../types/jwt';

    export const statusGetSchema: MCPToolSchema = {
      name: 'status.get',
      description: 'Get agent statuses for a BMAD project',
      scope: MCP_SCOPES.STATUS_READ,
      parameters: [
        {
          name: 'project_id',
          type: 'string',
          description: 'Project UUID',
          required: true,
        },
      ],
      returns: {
        type: 'object',
        description: 'Agent statuses',
        schema: {
          agents: 'array',
          timestamp: 'string',
        },
      },
    };
    ```

  - [ ] Implement handler:

    ```typescript
    import { prisma } from '@/lib/db/prisma';
    import { logMCPAudit } from '../audit-logger';
    import { MCPToolHandler, MCPToolResult } from '../types/tool';

    export const statusGetHandler: MCPToolHandler = async (
      args,
      token,
      projectId,
    ) => {
      try {
        // Validate project exists
        const project = await prisma.project.findUnique({
          where: { id: projectId },
        });

        if (!project) {
          return {
            success: false,
            error: {
              code: 'PROJECT_NOT_FOUND',
              message: `Project '${projectId}' not found`,
            },
          };
        }

        // Query agent statuses (placeholder - table doesn't exist yet)
        // In Epic 3, this will query the agent_status table
        // For now, return mock data structure
        const agents = [
          {
            agent: 'Analyst',
            status: 'idle',
            lastSeen: new Date().toISOString(),
          },
          {
            agent: 'PM',
            status: 'idle',
            lastSeen: new Date().toISOString(),
          },
          // ... other agents
        ];

        return {
          success: true,
          data: {
            agents,
            timestamp: new Date().toISOString(),
          },
        };
      } catch (error) {
        return {
          success: false,
          error: {
            code: 'DATABASE_ERROR',
            message: error instanceof Error ? error.message : 'Unknown error',
          },
        };
      }
    };
    ```

  - [ ] Register tool in `tool-registry.ts`:
    ```typescript
    import { statusGetSchema, statusGetHandler } from './tools/status';
    toolRegistry.register(statusGetSchema, statusGetHandler);
    ```

- [ ] **Task 4: Implement `conflicts.list` Tool** (AC: 4, 5, 6)
  - [ ] Create `lib/mcp/tools/conflicts.ts` file
  - [ ] Define schema:
    ```typescript
    export const conflictsListSchema: MCPToolSchema = {
      name: 'conflicts.list',
      description: 'List active conflicts for a BMAD project',
      scope: MCP_SCOPES.CONFLICTS_READ,
      parameters: [
        {
          name: 'project_id',
          type: 'string',
          description: 'Project UUID',
          required: true,
        },
      ],
      returns: {
        type: 'object',
        description: 'Active conflicts',
        schema: {
          conflicts: 'array',
          count: 'number',
        },
      },
    };
    ```
  - [ ] Implement handler:

    ```typescript
    export const conflictsListHandler: MCPToolHandler = async (
      args,
      token,
      projectId,
    ) => {
      try {
        const project = await prisma.project.findUnique({
          where: { id: projectId },
        });

        if (!project) {
          return {
            success: false,
            error: {
              code: 'PROJECT_NOT_FOUND',
              message: `Project '${projectId}' not found`,
            },
          };
        }

        // Query conflicts (placeholder - table doesn't exist yet)
        // In Epic 5, this will query the conflict table
        const conflicts = [];

        return {
          success: true,
          data: {
            conflicts,
            count: conflicts.length,
          },
        };
      } catch (error) {
        return {
          success: false,
          error: {
            code: 'DATABASE_ERROR',
            message: error instanceof Error ? error.message : 'Unknown error',
          },
        };
      }
    };
    ```

  - [ ] Register tool

- [ ] **Task 5: Implement `kanban.moveStory` Tool** (AC: 4, 5, 6)
  - [ ] Create `lib/mcp/tools/kanban.ts` file
  - [ ] Define schema:
    ```typescript
    export const kanbanMoveStorySchema: MCPToolSchema = {
      name: 'kanban.moveStory',
      description:
        'Move a story to a different kanban lane (Backlog/Ready/Done)',
      scope: MCP_SCOPES.KANBAN_WRITE,
      parameters: [
        {
          name: 'project_id',
          type: 'string',
          description: 'Project UUID',
          required: true,
        },
        {
          name: 'story_id',
          type: 'string',
          description: 'Story identifier (e.g., "1.3", "2.1")',
          required: true,
        },
        {
          name: 'lane',
          type: 'string',
          description: 'Target lane: "Backlog", "Ready", "Done"',
          required: true,
        },
      ],
      returns: {
        type: 'object',
        description: 'Updated story',
        schema: {
          storyId: 'string',
          lane: 'string',
          updatedAt: 'string',
        },
      },
    };
    ```
  - [ ] Implement handler:

    ```typescript
    import * as fs from 'fs/promises';
    import * as path from 'path';
    import * as yaml from 'js-yaml';

    export const kanbanMoveStoryHandler: MCPToolHandler = async (
      args,
      token,
      projectId,
    ) => {
      try {
        const { story_id, lane } = args;

        // Validate lane
        const validLanes = ['Backlog', 'Ready', 'Done'];
        if (!validLanes.includes(lane)) {
          return {
            success: false,
            error: {
              code: 'INVALID_LANE',
              message: `Lane must be one of: ${validLanes.join(', ')}`,
            },
          };
        }

        // Get project to find story location
        const project = await prisma.project.findUnique({
          where: { id: projectId },
        });

        if (!project) {
          return {
            success: false,
            error: {
              code: 'PROJECT_NOT_FOUND',
              message: `Project '${projectId}' not found`,
            },
          };
        }

        // Parse project config to find devStoryLocation
        const config = project.config as any;
        const storyLocation = config.devStoryLocation || 'docs/stories';

        // Story file path (assumes stories are named like "1.3.story.md")
        const storyPath = path.join(
          process.cwd(),
          storyLocation,
          `${story_id}.story.md`,
        );

        // Read story file
        let content: string;
        try {
          content = await fs.readFile(storyPath, 'utf-8');
        } catch (error) {
          return {
            success: false,
            error: {
              code: 'STORY_NOT_FOUND',
              message: `Story '${story_id}' not found`,
            },
          };
        }

        // Update Status field (simple string replacement)
        const updatedContent = content.replace(
          /^## Status\s*\n\s*\w+/m,
          `## Status\n\n${lane}`,
        );

        // Write back
        await fs.writeFile(storyPath, updatedContent, 'utf-8');

        return {
          success: true,
          data: {
            storyId: story_id,
            lane,
            updatedAt: new Date().toISOString(),
          },
        };
      } catch (error) {
        return {
          success: false,
          error: {
            code: 'EXECUTION_ERROR',
            message: error instanceof Error ? error.message : 'Unknown error',
          },
        };
      }
    };
    ```

  - [ ] Register tool

- [ ] **Task 6: Implement `gates.list` Tool** (AC: 4, 5, 6)
  - [ ] Create `lib/mcp/tools/gates.ts` file
  - [ ] Define schema:
    ```typescript
    export const gatesListSchema: MCPToolSchema = {
      name: 'gates.list',
      description: 'List quality gate statuses for a BMAD project',
      scope: MCP_SCOPES.GATES_READ,
      parameters: [
        {
          name: 'project_id',
          type: 'string',
          description: 'Project UUID',
          required: true,
        },
      ],
      returns: {
        type: 'object',
        description: 'Quality gate statuses',
        schema: {
          gates: 'array',
          passCount: 'number',
          failCount: 'number',
        },
      },
    };
    ```
  - [ ] Implement handler:

    ```typescript
    export const gatesListHandler: MCPToolHandler = async (
      args,
      token,
      projectId,
    ) => {
      try {
        const project = await prisma.project.findUnique({
          where: { id: projectId },
        });

        if (!project) {
          return {
            success: false,
            error: {
              code: 'PROJECT_NOT_FOUND',
              message: `Project '${projectId}' not found`,
            },
          };
        }

        // Query gates (placeholder - table doesn't exist yet)
        // In Epic 6, this will query the gate table
        const gates = [];

        return {
          success: true,
          data: {
            gates,
            passCount: 0,
            failCount: 0,
          },
        };
      } catch (error) {
        return {
          success: false,
          error: {
            code: 'DATABASE_ERROR',
            message: error instanceof Error ? error.message : 'Unknown error',
          },
        };
      }
    };
    ```

  - [ ] Register tool

- [ ] **Task 7: Implement `runs.list` Tool** (AC: 4, 5, 6)
  - [ ] Create `lib/mcp/tools/runs.ts` file
  - [ ] Define schema:
    ```typescript
    export const runsListSchema: MCPToolSchema = {
      name: 'runs.list',
      description: 'List agent execution runs with optional filters',
      scope: MCP_SCOPES.RUNS_READ,
      parameters: [
        {
          name: 'project_id',
          type: 'string',
          description: 'Project UUID',
          required: true,
        },
        {
          name: 'filters',
          type: 'object',
          description: 'Optional filters (agent, status, limit)',
          required: false,
          schema: {
            agent: 'string',
            status: 'string',
            limit: 'number',
          },
        },
      ],
      returns: {
        type: 'object',
        description: 'Agent runs',
        schema: {
          runs: 'array',
          count: 'number',
        },
      },
    };
    ```
  - [ ] Implement handler:

    ```typescript
    export const runsListHandler: MCPToolHandler = async (
      args,
      token,
      projectId,
    ) => {
      try {
        const { filters = {} } = args;

        const project = await prisma.project.findUnique({
          where: { id: projectId },
        });

        if (!project) {
          return {
            success: false,
            error: {
              code: 'PROJECT_NOT_FOUND',
              message: `Project '${projectId}' not found`,
            },
          };
        }

        // Query runs (placeholder - table doesn't exist yet)
        // In Epic 6, this will query the run table
        const runs = [];

        return {
          success: true,
          data: {
            runs,
            count: runs.length,
          },
        };
      } catch (error) {
        return {
          success: false,
          error: {
            code: 'DATABASE_ERROR',
            message: error instanceof Error ? error.message : 'Unknown error',
          },
        };
      }
    };
    ```

  - [ ] Register tool

- [ ] **Task 8: Create Tool Discovery Endpoint** (AC: 1)
  - [ ] Open `lib/mcp/server.ts`
  - [ ] Import `toolRegistry` from `./tool-registry`
  - [ ] Add route:
    ```typescript
    app.get('/mcp/tools', async (request, reply) => {
      const tools = toolRegistry.getAll();
      return {
        tools,
        count: tools.length,
        timestamp: new Date().toISOString(),
      };
    });
    ```
  - [ ] Test: `curl http://localhost:4000/mcp/tools -H "Authorization: Bearer <token>"`
  - [ ] Verify returns all 5 tool schemas

- [ ] **Task 9: Create Tool Invocation Endpoint** (AC: 2, 6)
  - [ ] In `lib/mcp/server.ts`, add route:

    ```typescript
    import { requireScope } from './auth-middleware';
    import { logMCPAudit } from './audit-logger';
    import { MCPResult } from '@prisma/client';

    app.post<{ Body: MCPToolInvocation }>(
      '/mcp/invoke',
      async (request, reply) => {
        const { tool, projectId, args } = request.body;
        const token = (request as any).mcpToken as MCPTokenPayload;

        // Validate request
        if (!tool || !projectId) {
          return reply.status(400).send({
            error: {
              code: 'INVALID_REQUEST',
              message: 'Missing required fields: tool, projectId',
            },
          });
        }

        // Get tool schema to check scope
        const toolDef = toolRegistry.get(tool);
        if (!toolDef) {
          return reply.status(404).send({
            error: {
              code: 'TOOL_NOT_FOUND',
              message: `Tool '${tool}' not found`,
            },
          });
        }

        // Check scope
        if (!token.scopes.includes(toolDef.schema.scope)) {
          return reply.status(403).send({
            error: {
              code: 'INSUFFICIENT_SCOPE',
              message: `Required scope: ${toolDef.schema.scope}`,
              scopes: token.scopes,
            },
          });
        }

        // Invoke tool
        const result = await toolRegistry.invoke(tool, args, token, projectId);

        // Log audit
        await logMCPAudit({
          projectId,
          token,
          tool,
          scope: toolDef.schema.scope,
          args,
          result: result.success ? MCPResult.SUCCESS : MCPResult.FAILURE,
          errorMessage: result.error?.message,
          ipAddress: request.ip,
          userAgent: request.headers['user-agent'] || 'unknown',
        });

        // Return result
        if (!result.success) {
          return reply.status(400).send(result);
        }

        return result;
      },
    );
    ```

  - [ ] Test: `curl -X POST http://localhost:4000/mcp/invoke -H "Authorization: Bearer <token>" -d '{"tool":"status.get","projectId":"<uuid>","args":{}}'`

- [ ] **Task 10: Write Integration Tests** (AC: 7, 9)
  - [ ] Create `tests/integration/mcp/tools.test.ts`
  - [ ] Setup test database and MCP server
  - [ ] Write test: `GET /mcp/tools returns all 5 tools`
    - [ ] Generate valid JWT with all scopes
    - [ ] Make request to `/mcp/tools`
    - [ ] Assert response contains 5 tools
    - [ ] Assert each tool has name, description, scope, parameters
  - [ ] Write test: `status.get returns agent statuses`
    - [ ] Create test project in database
    - [ ] Invoke `status.get` tool
    - [ ] Assert returns agents array
  - [ ] Write test: `conflicts.list returns empty array (no conflicts yet)`
    - [ ] Invoke `conflicts.list` tool
    - [ ] Assert returns empty conflicts array
  - [ ] Write test: `kanban.moveStory updates story status`
    - [ ] Create test story file
    - [ ] Invoke `kanban.moveStory` with lane="Done"
    - [ ] Read story file
    - [ ] Assert status changed to "Done"
    - [ ] Cleanup test file
  - [ ] Write test: `gates.list returns empty array (no gates yet)`
    - [ ] Invoke `gates.list` tool
    - [ ] Assert returns empty gates array
  - [ ] Write test: `runs.list returns empty array (no runs yet)`
    - [ ] Invoke `runs.list` tool
    - [ ] Assert returns empty runs array
  - [ ] Write test: `tool invocation without required scope fails`
    - [ ] Generate JWT without `mcp:status.read` scope
    - [ ] Invoke `status.get` tool
    - [ ] Assert returns 403 with `INSUFFICIENT_SCOPE`
  - [ ] Write test: `audit log created after tool invocation`
    - [ ] Invoke any tool
    - [ ] Query `mcp_audit_logs` table
    - [ ] Assert log entry exists with correct tool, actor, result

- [ ] **Task 11: Create Postman Collection** (AC: 8)
  - [ ] Create `docs/postman/mcp-tools.postman_collection.json`
  - [ ] Add collection with environment variables:
    - `MCP_BASE_URL`: `http://localhost:4000` or `https://jive-mcp-staging.railway.app`
    - `JWT_TOKEN`: `<generated-token>`
    - `PROJECT_ID`: `<test-project-uuid>`
  - [ ] Add requests:
    1. Health Check (`GET /mcp/health`)
    2. Get Tools (`GET /mcp/tools`)
    3. Invoke status.get (`POST /mcp/invoke`)
    4. Invoke conflicts.list
    5. Invoke kanban.moveStory
    6. Invoke gates.list
    7. Invoke runs.list
  - [ ] Add pre-request script to generate JWT (using test secret)
  - [ ] Test all requests locally

- [ ] **Task 12: Create curl Examples** (AC: 8)
  - [ ] Create `docs/mcp-tools-examples.md` file
  - [ ] Document curl commands:

    ```bash
    # Generate test JWT (requires web service)
    export JWT_TOKEN="<token-from-web-service>"

    # Get tools
    curl http://localhost:4000/mcp/tools \
      -H "Authorization: Bearer $JWT_TOKEN"

    # Invoke status.get
    curl -X POST http://localhost:4000/mcp/invoke \
      -H "Authorization: Bearer $JWT_TOKEN" \
      -H "Content-Type: application/json" \
      -d '{
        "tool": "status.get",
        "projectId": "<project-uuid>",
        "args": {}
      }'

    # Invoke kanban.moveStory
    curl -X POST http://localhost:4000/mcp/invoke \
      -H "Authorization: Bearer $JWT_TOKEN" \
      -H "Content-Type: application/json" \
      -d '{
        "tool": "kanban.moveStory",
        "projectId": "<project-uuid>",
        "args": {
          "story_id": "1.3",
          "lane": "Done"
        }
      }'
    ```

  - [ ] Include expected responses for each example

- [ ] **Task 13: Update MCP Scopes** (AC: 4)
  - [ ] Open `lib/mcp/types/jwt.ts`
  - [ ] Verify all 5 scopes defined:
    - `mcp:status.read`
    - `mcp:conflicts.read`
    - `mcp:kanban.write`
    - `mcp:gates.read`
    - `mcp:runs.read`
  - [ ] Export scope constants

- [ ] **Task 14: Verify All Tests Pass** (AC: 9)
  - [ ] Run unit tests: `pnpm test tests/unit/mcp/`
  - [ ] Run integration tests: `pnpm test tests/integration/mcp/tools.test.ts`
  - [ ] Verify test coverage >80% for tool handlers
  - [ ] Run `pnpm type-check` to ensure no TypeScript errors
  - [ ] Run `pnpm lint` to ensure no linting errors

- [ ] **Task 15: Deploy to Railway** (AC: all)
  - [ ] Push Story 2.4 implementation to staging branch
  - [ ] Verify Railway deployment succeeds
  - [ ] Test tool discovery: `curl https://jive-mcp-staging.railway.app/mcp/tools -H "Authorization: Bearer <token>"`
  - [ ] Test tool invocation on Railway with real database
  - [ ] Verify audit logs created in Railway Postgres

## Dev Notes

### Previous Story Insights

**[From Story 2.1, 2.2, 2.3]**

Key context from previous stories:

1. **Prisma Setup:** Story 2.1 created database schema. Story 2.4 queries `project` table and will query future tables (`agent_status`, `conflict`, `gate`, `run`) in Epic 3+.

2. **MCP Server:** Story 2.2 created Fastify HTTP server. Story 2.4 adds `/mcp/tools` and `/mcp/invoke` routes.

3. **Authentication:** Story 2.3 created JWT verification and scope authorization. Story 2.4 uses `requireScope()` middleware to enforce tool-specific scopes.

4. **Audit Logging:** Story 2.3 created `logMCPAudit()` function. Story 2.4 calls it after every tool invocation.

### Architecture Context

**[Source: docs/architecture.md#mcp-server-components]**

#### MCP Tool Discovery (lines 871-895)

**Tool Discovery Endpoint:**

`GET /mcp/tools` returns a list of all registered tools with their schemas. IDE agents call this endpoint to discover available tools.

**Response Format:**

```json
{
  "tools": [
    {
      "name": "status.get",
      "description": "Get agent statuses for a BMAD project",
      "scope": "mcp:status.read",
      "parameters": [
        {
          "name": "project_id",
          "type": "string",
          "description": "Project UUID",
          "required": true
        }
      ],
      "returns": {
        "type": "object",
        "description": "Agent statuses",
        "schema": {
          "agents": "array",
          "timestamp": "string"
        }
      }
    }
    // ... other tools
  ],
  "count": 5,
  "timestamp": "2025-10-15T15:30:00Z"
}
```

**[Source: docs/architecture.md#mcp-tool-invocation]**

#### MCP Tool Invocation (lines 896-919)

**Tool Invocation Endpoint:**

`POST /mcp/invoke` executes a registered tool with the provided arguments.

**Request Format:**

```json
{
  "tool": "status.get",
  "projectId": "project-uuid",
  "args": {}
}
```

**Response Format (Success):**

```json
{
  "success": true,
  "data": {
    "agents": [
      {
        "agent": "Analyst",
        "status": "idle",
        "lastSeen": "2025-10-15T15:30:00Z"
      }
    ],
    "timestamp": "2025-10-15T15:30:00Z"
  }
}
```

**Response Format (Failure):**

```json
{
  "success": false,
  "error": {
    "code": "PROJECT_NOT_FOUND",
    "message": "Project 'invalid-uuid' not found"
  }
}
```

**[Source: docs/architecture.md#phase-1-mcp-tools]**

#### Phase 1 MCP Tools (lines 920-1020)

Story 2.4 implements the 5 core tools identified in the architecture:

**1. status.get**

- **Scope:** `mcp:status.read`
- **Parameters:** `project_id`
- **Returns:** Agent statuses (Analyst, PM, Architect, SM, Dev, QA)
- **Database:** Queries `agent_status` table (Epic 3 - placeholder in Story 2.4)

**2. conflicts.list**

- **Scope:** `mcp:conflicts.read`
- **Parameters:** `project_id`
- **Returns:** Active conflicts between artifacts
- **Database:** Queries `conflict` table (Epic 5 - placeholder in Story 2.4)

**3. kanban.moveStory**

- **Scope:** `mcp:kanban.write`
- **Parameters:** `project_id`, `story_id`, `lane`
- **Returns:** Updated story metadata
- **File System:** Reads/writes story markdown file, updates `## Status` field

**4. gates.list**

- **Scope:** `mcp:gates.read`
- **Parameters:** `project_id`
- **Returns:** Quality gate statuses (pass/fail)
- **Database:** Queries `gate` table (Epic 6 - placeholder in Story 2.4)

**5. runs.list**

- **Scope:** `mcp:runs.read`
- **Parameters:** `project_id`, `filters`
- **Returns:** Agent execution runs with filters
- **Database:** Queries `run` table (Epic 6 - placeholder in Story 2.4)

**Note:** Tools return placeholder data in Story 2.4 since database tables don't exist yet. Future epics will implement full functionality.

### Testing Strategy

**[Source: docs/architecture.md#testing-strategy]**

**Integration Test Requirements for Story 2.4:**

- **Coverage Target:** All 5 tools tested with success and failure cases
- **Test Database:** Use test Postgres with sample project data
- **Test Isolation:** Create/cleanup test projects and story files
- **Test Categories:**
  1. Tool Discovery: Verify all tools returned by `/mcp/tools`
  2. Tool Invocation Success: Each tool returns expected data structure
  3. Tool Invocation Failure: Invalid project ID, missing parameters, insufficient scope
  4. Audit Logging: Verify audit logs created for each invocation
  5. File System (kanban): Verify story file updated correctly

**Mock Patterns for Tools:**

```typescript
// Mock Prisma for status.get test
vi.mock('@/lib/db/prisma', () => ({
  prisma: {
    project: {
      findUnique: vi.fn().mockResolvedValue({
        id: 'test-project-id',
        name: 'Test Project',
        repoUrl: 'https://github.com/test/repo',
        config: { devStoryLocation: 'docs/stories' },
      }),
    },
  },
}));

// Mock file system for kanban.moveStory test
import * as fs from 'fs/promises';
vi.mock('fs/promises', () => ({
  readFile: vi.fn().mockResolvedValue('## Status\n\nReady\n\n...'),
  writeFile: vi.fn().mockResolvedValue(undefined),
}));
```

### Tech Stack Additions

**New Dependencies for Story 2.4:**

No new dependencies required. Story 2.4 uses existing dependencies from Stories 2.1-2.3:

- `@prisma/client` (database queries)
- `jsonwebtoken` (JWT verification)
- `ioredis` (rate limiting)
- `js-yaml` (future use for parsing story YAML frontmatter)

### File Locations

**New Files Created in Story 2.4:**

```
jive/
├── lib/
│   └── mcp/
│       ├── types/
│       │   └── tool.ts              # NEW - Tool schema types
│       ├── tool-registry.ts         # NEW - Tool registry singleton
│       └── tools/
│           ├── status.ts            # NEW - status.get tool
│           ├── conflicts.ts         # NEW - conflicts.list tool
│           ├── kanban.ts            # NEW - kanban.moveStory tool
│           ├── gates.ts             # NEW - gates.list tool
│           └── runs.ts              # NEW - runs.list tool
├── tests/
│   └── integration/
│       └── mcp/
│           └── tools.test.ts        # NEW - Tool integration tests
├── docs/
│   ├── postman/
│   │   └── mcp-tools.postman_collection.json  # NEW - Postman collection
│   └── mcp-tools-examples.md        # NEW - curl examples
└── lib/mcp/server.ts                # UPDATE - Add /mcp/tools and /mcp/invoke routes
```

### Coding Standards

**[Source: docs/architecture.md#coding-standards]**

**Critical Rules for Story 2.4:**

1. **Tool Handler Pattern:** All handlers follow same signature:

   ```typescript
   async (args, token, projectId) => Promise<MCPToolResult>;
   ```

2. **Error Handling:** Tools return structured errors, never throw:

   ```typescript
   return {
     success: false,
     error: {
       code: 'PROJECT_NOT_FOUND',
       message: `Project '${projectId}' not found`,
     },
   };
   ```

3. **Validation:** Always validate project exists before querying data:

   ```typescript
   const project = await prisma.project.findUnique({ where: { id: projectId } });
   if (!project) {
     return { success: false, error: { code: 'PROJECT_NOT_FOUND', ... } };
   }
   ```

4. **Audit Logging:** Always log after tool execution (in `/mcp/invoke` endpoint, not in individual tools)

5. **Type Safety:** Use Prisma-generated types and custom MCP types:
   ```typescript
   import { Project } from '@prisma/client';
   import { MCPToolResult } from '../types/tool';
   ```

### Deployment Strategy

**[Source: docs/architecture.md#deployment-architecture]**

**Railway Deployment for Story 2.4:**

- No new environment variables required
- MCP server deployment unchanged from Story 2.2
- Verify audit logs appear in Railway Postgres after tool invocations
- Test tool invocations on Railway using Postman collection

**Phase 1 vs Phase 2 Tools:**

- **Phase 1 (Story 2.4):** 5 read-only tools (except kanban.moveStory)
- **Phase 2 (Future):** Advanced tools (artifact.update, conflict.resolve, gate.override)

### Security Considerations

**[Source: docs/architecture.md#security-requirements]**

**Tool Security:**

1. **Scope Enforcement:** Each tool requires specific scope. Verified in `/mcp/invoke` endpoint before tool execution.

2. **Project Access Control:** Future enhancement - verify token's `projectIds` claim matches requested `projectId`.

3. **File System Access (kanban):** Only allow access to story files within `devStoryLocation` directory. Prevent path traversal attacks.

4. **Input Validation:** Validate all tool arguments (type, required fields, format).

**kanban.moveStory Security:**

```typescript
// Prevent path traversal
const storyPath = path.join(
  process.cwd(),
  storyLocation,
  `${story_id}.story.md`,
);
const resolvedPath = path.resolve(storyPath);
const allowedDir = path.resolve(process.cwd(), storyLocation);

if (!resolvedPath.startsWith(allowedDir)) {
  return {
    success: false,
    error: { code: 'INVALID_STORY_PATH', message: 'Path traversal detected' },
  };
}
```

### Relationship to Future Stories

**Story 2.4 Foundation for:**

- **Story 2.5 (Orchestrator):** Orchestrator publishes events, tools query updated data
- **Epic 3 (Agent Status):** `status.get` tool queries real agent statuses from database
- **Epic 5 (Conflict Detection):** `conflicts.list` tool queries real conflicts from database
- **Epic 6 (Quality Gates):** `gates.list` and `runs.list` query real gate/run data

**Future Tool Enhancements (Deferred):**

- `artifact.update`: Update artifact metadata (Phase 2)
- `conflict.resolve`: Mark conflict as resolved (Phase 2)
- `gate.override`: Override gate failure (admin-only, Phase 2)
- `webhook.replay`: Replay webhook event (debugging, Phase 2)

### Performance Considerations

**Tool Performance:**

- **Database Queries:** Each tool makes 1-2 Prisma queries (project validation + data fetch)
- **Target Latency:** <200ms per tool invocation
- **Caching:** Future optimization - cache project metadata for 1 minute

**File System Performance (kanban):**

- **Read/Write Latency:** ~5-10ms for markdown file operations
- **Concurrency:** No locking mechanism in Phase 1 (risk of race condition if multiple IDE agents move same story simultaneously)
- **Future Enhancement:** Use database for story status instead of file system

## Change Log

| Date       | Version | Description                                 | Author |
| ---------- | ------- | ------------------------------------------- | ------ |
| 2025-10-15 | 1.0     | Story created for Epic 2 MCP tools registry | SM Bob |

## Dev Agent Record

### Agent Model Used

_To be filled by Dev Agent_

### Debug Log References

_To be filled by Dev Agent_

### Completion Notes

_To be filled by Dev Agent_

### File List

_To be filled by Dev Agent_

## QA Results

_To be filled by QA Agent after implementation_
