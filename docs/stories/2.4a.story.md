# Story 2.4a: MCP Tool Registry + Core Read Tools

## Status

Draft

## Story

**As an** IDE Agent (Cursor/Codex),
**I want** to discover and invoke JIVE tools via Model Context Protocol,
**so that** I can query project status from my IDE.

## Acceptance Criteria

1. Tool discovery endpoint `GET /mcp/tools` returns tool schemas
2. Tool invocation endpoint `POST /mcp/invoke` dispatches to registered tool handlers
3. Tool registry pattern implemented (ToolRegistry class)
4. **2 tools implemented:** status.get, conflicts.list (read-only tools with placeholder data)
5. Each tool queries Prisma for data (placeholder data for tables not yet created)
6. Each tool logs to mcp_audit_logs via Story 2.3b audit logger
7. Integration tests for registry and 2 tools
8. All tests pass (`pnpm test`)

## Tasks / Subtasks

**Note:** Full task details available in original Story 2.4 (`docs/stories/2.4.story.md`). This story implements Tasks 1-4, 8-9 (partial), 13 (partial), 14.

### From Original Story 2.4:

- [ ] **Task 1: Define Tool Schema Types** (AC: 1, 2)
  - Create `lib/mcp/types/tool.ts`
  - Define MCPToolParameter, MCPToolSchema, MCPToolInvocation, MCPToolResult interfaces
  - Export all types

- [ ] **Task 2: Create Tool Registry** (AC: 3)
  - Create `lib/mcp/tool-registry.ts`
  - Define MCPToolHandler type
  - Implement ToolRegistry class with register(), get(), getAll(), invoke() methods
  - Export toolRegistry singleton

- [ ] **Task 3: Implement `status.get` Tool** (AC: 4, 5, 6)
  - Create `lib/mcp/tools/status.ts`
  - Define tool schema with scope `mcp:status.read`
  - Implement handler that queries Prisma for project
  - Return placeholder agent status data (agent_status table not created yet in Epic 2)
  - Register tool in tool-registry.ts

- [ ] **Task 4: Implement `conflicts.list` Tool** (AC: 4, 5, 6)
  - Create `lib/mcp/tools/conflicts.ts`
  - Define tool schema with scope `mcp:conflicts.read`
  - Implement handler that validates project exists
  - Return empty conflicts array (conflict table created in Epic 5)
  - Register tool in tool-registry.ts

- [ ] **Task 8: Create Tool Discovery Endpoint** (AC: 1)
  - Open `lib/mcp/server.ts`
  - Import toolRegistry
  - Add GET /mcp/tools route:
    ```typescript
    app.get('/mcp/tools', async (request, reply) => {
      const tools = toolRegistry.getAll();
      return {
        tools,
        count: tools.length,
        timestamp: new Date().toISOString(),
      };
    });
    ```
  - Test: `curl http://localhost:4000/mcp/tools -H "Authorization: Bearer <token>"`

- [ ] **Task 9: Create Tool Invocation Endpoint** (AC: 2, 6) - **PARTIAL (2 tools only)**
  - In `lib/mcp/server.ts`, add POST /mcp/invoke route
  - Import requireScope from auth-middleware, logMCPAudit from audit-logger
  - Implement tool invocation with scope check and audit logging:

    ```typescript
    import { requireScope } from './auth-middleware';
    import { logMCPAudit } from './audit-logger';
    import { MCPResult } from '@prisma/client';

    app.post<{ Body: MCPToolInvocation }>(
      '/mcp/invoke',
      async (request, reply) => {
        const { tool, projectId, args } = request.body;
        const token = (request as any).mcpToken as MCPTokenPayload;

        if (!tool || !projectId) {
          return reply.status(400).send({
            error: {
              code: 'INVALID_REQUEST',
              message: 'Missing required fields: tool, projectId',
            },
          });
        }

        const toolDef = toolRegistry.get(tool);
        if (!toolDef) {
          return reply.status(404).send({
            error: {
              code: 'TOOL_NOT_FOUND',
              message: `Tool '${tool}' not found`,
            },
          });
        }

        // Check scope
        if (!token.scopes.includes(toolDef.schema.scope)) {
          return reply.status(403).send({
            error: {
              code: 'INSUFFICIENT_SCOPE',
              message: `Required scope: ${toolDef.schema.scope}`,
              scopes: token.scopes,
            },
          });
        }

        // Invoke tool
        const result = await toolRegistry.invoke(tool, args, token, projectId);

        // Log audit
        await logMCPAudit({
          projectId,
          token,
          tool,
          scope: toolDef.schema.scope,
          args,
          result: result.success ? MCPResult.SUCCESS : MCPResult.FAILURE,
          errorMessage: result.error?.message,
          ipAddress: request.ip,
          userAgent: request.headers['user-agent'] || 'unknown',
        });

        if (!result.success) {
          return reply.status(400).send(result);
        }

        return result;
      },
    );
    ```

- [ ] **Task 10: Write Integration Tests** (AC: 7, 8) - **PARTIAL (2 tools only)**
  - Create `tests/integration/mcp/tools.test.ts`
  - Setup test database and MCP server
  - Write test: `GET /mcp/tools returns 2 tools`
    - Generate valid JWT with all scopes
    - Make request to `/mcp/tools`
    - Assert response contains 2 tools (status.get, conflicts.list)
  - Write test: `status.get returns agent statuses`
    - Create test project in database
    - Invoke status.get tool via POST /mcp/invoke
    - Assert returns agents array (placeholder data)
  - Write test: `conflicts.list returns empty array`
    - Invoke conflicts.list tool
    - Assert returns empty conflicts array
  - Write test: `tool invocation without required scope fails`
    - Generate JWT without mcp:status.read scope
    - Invoke status.get tool
    - Assert returns 403 with INSUFFICIENT_SCOPE
  - Write test: `audit log created after tool invocation`
    - Invoke any tool
    - Query mcp_audit_logs table
    - Assert log entry exists with correct tool, actor, result

- [ ] **Task 13: Update MCP Scopes** (AC: 4) - **PARTIAL**
  - Open `lib/mcp/types/jwt.ts`
  - Verify scopes defined for 2 tools:
    - `mcp:status.read`
    - `mcp:conflicts.read`
  - Export scope constants

- [ ] **Task 14: Verify All Tests Pass** (AC: 8)
  - Run unit tests for tool registry
  - Run integration tests: `pnpm test tests/integration/mcp/tools.test.ts`
  - Verify test coverage >80% for tool handlers
  - Run `pnpm type-check` to ensure no TypeScript errors
  - Run `pnpm lint` to ensure no linting errors

- [ ] **Task 15: Deploy to Railway** (AC: all)
  - Push Story 2.4a implementation to staging branch
  - Verify Railway deployment succeeds
  - Test tool discovery: `curl https://jive-mcp-staging.railway.app/mcp/tools -H "Authorization: Bearer <token>"`
  - Test tool invocation on Railway with real database

## Dev Notes

### Story Split Context

This story is split from original Story 2.4 to:

1. **Validate tool pattern early:** Implement registry + 2 simple tools to prove the pattern
2. **Reduce complexity:** 2 read-only tools vs 5 mixed read/write tools
3. **Enable incremental value:** Deliver working MCP server with basic query capabilities

**Story 2.4b will add:** 3 remaining tools (kanban.moveStory, gates.list, runs.list) + documentation

### Previous Story Insights

**[From Story 2.1, 2.2, 2.3a, 2.3b]**

1. **Database:** Project table exists. Agent_status, conflict, gate, run tables created in Epic 3-6.
2. **MCP Server:** Fastify server with JWT auth, rate limiting, audit logging middleware.
3. **Auth Middleware:** Story 2.3a provides requireScope() for scope-based authorization.
4. **Audit Logger:** Story 2.3b provides logMCPAudit() for tracking tool invocations.

### Architecture Context

**[Source: docs/architecture.md#mcp-tool-discovery]**

Full architecture details available in original Story 2.4 Dev Notes. Key points:

- Tool schemas use OpenAPI-like format
- Tool registry uses singleton pattern
- Tools return structured MCPToolResult (success boolean + data or error)
- Placeholder data is acceptable in Epic 2 (real data in Epic 3+)

### File Locations

**New Files Created in Story 2.4a:**

```
jive/
├── lib/
│   └── mcp/
│       ├── types/
│       │   └── tool.ts              # NEW - Tool schema types
│       ├── tool-registry.ts         # NEW - Tool registry singleton
│       └── tools/
│           ├── status.ts            # NEW - status.get tool
│           └── conflicts.ts         # NEW - conflicts.list tool
├── tests/
│   └── integration/
│       └── mcp/
│           └── tools.test.ts        # NEW - Tool integration tests
└── lib/mcp/server.ts                # UPDATE - Add /mcp/tools and /mcp/invoke routes
```

### Testing Strategy

**Unit Tests:** Minimal for Story 2.4a (just tool handlers). Registry tested via integration tests.

**Integration Tests:** Primary testing strategy - test full flow:

1. Tool discovery (GET /mcp/tools)
2. Tool invocation (POST /mcp/invoke)
3. Scope authorization
4. Audit logging

**Coverage Target:** >80% for tool handlers and endpoints

## Change Log

| Date       | Version | Description                                           | Author |
| ---------- | ------- | ----------------------------------------------------- | ------ |
| 2025-10-25 | 1.0     | Story split from 2.4 for tool registry + 2 core tools | SM Bob |

## Dev Agent Record

### Agent Model Used

_To be filled by Dev Agent_

### Debug Log References

_To be filled by Dev Agent_

### Completion Notes

_To be filled by Dev Agent_

### File List

_To be filled by Dev Agent_

## QA Results

_To be filled by QA Agent after implementation_
