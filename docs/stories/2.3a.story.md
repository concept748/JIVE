# Story 2.3a: MCP JWT Authentication

## Status

Draft

## Story

**As a** Security Engineer,
**I want** MCP tool invocations authenticated via JWT with scope-based authorization,
**so that** only authorized IDE agents can access JIVE data with appropriate permissions.

## Acceptance Criteria

1. JWT verification middleware created (verifies signature, expiry, issuer)
2. Scope-based authorization implemented (requireScope() function)
3. Unauthorized requests return 401 with error details (invalid token, expired, missing token)
4. Insufficient scope returns 403 with required scope in error message
5. Unit tests for auth middleware (valid/invalid tokens, expired tokens, scope checks)
6. Integration test: MCP tool call with valid JWT succeeds, invalid JWT fails
7. All tests pass (`pnpm test`)

## Tasks / Subtasks

- [ ] **Task 1: Install JWT Dependencies** (AC: 1)
  - [ ] Install jsonwebtoken: `pnpm add jsonwebtoken`
  - [ ] Install @types/jsonwebtoken: `pnpm add -D @types/jsonwebtoken`
  - [ ] Verify package.json includes both dependencies
  - [ ] Run `pnpm type-check` to ensure no errors

- [ ] **Task 2: Define JWT Schema & Types** (AC: 1, 2)
  - [ ] Create `lib/mcp/types/jwt.ts` file
  - [ ] Define JWT payload interface:
    ```typescript
    export interface MCPTokenPayload {
      sub: string; // Subject (IDE agent ID, e.g., "cursor-agent-abc123")
      iss: string; // Issuer (JIVE web service URL)
      aud: string; // Audience (MCP server URL)
      scopes: string[]; // Array of authorized scopes
      actorType: 'ide_agent' | 'web_user' | 'system';
      actorName: string; // Human-readable name (e.g., "Cursor IDE")
      projectIds?: string[]; // Optional: restrict to specific projects (future)
      iat: number; // Issued at (Unix timestamp)
      exp: number; // Expiration (Unix timestamp)
    }
    ```
  - [ ] Define MCP scopes enum:
    ```typescript
    export const MCP_SCOPES = {
      STATUS_READ: 'mcp:status.read',
      CONFLICTS_READ: 'mcp:conflicts.read',
      KANBAN_WRITE: 'mcp:kanban.write',
      GATES_READ: 'mcp:gates.read',
      RUNS_READ: 'mcp:runs.read',
    } as const;
    ```
  - [ ] Export all types and constants

- [ ] **Task 3: Create JWT Verification Middleware** (AC: 1, 3)
  - [ ] Create `lib/mcp/auth-middleware.ts` file
  - [ ] Import jsonwebtoken and types
  - [ ] Implement `verifyMCPToken()` function:

    ```typescript
    import jwt from 'jsonwebtoken';
    import { MCPTokenPayload } from './types/jwt';

    export async function verifyMCPToken(
      request: FastifyRequest,
      reply: FastifyReply,
    ): Promise<void> {
      try {
        // Extract token from Authorization header
        const authHeader = request.headers.authorization;
        if (!authHeader || !authHeader.startsWith('Bearer ')) {
          return reply.status(401).send({
            error: {
              code: 'MISSING_TOKEN',
              message: 'Authorization header missing or malformed',
            },
          });
        }

        const token = authHeader.substring(7); // Remove 'Bearer ' prefix

        // Verify token
        const secret = process.env.MCP_JWT_SECRET;
        if (!secret) {
          throw new Error('MCP_JWT_SECRET not configured');
        }

        const payload = jwt.verify(token, secret, {
          issuer: process.env.NEXT_PUBLIC_WEB_URL,
          audience: process.env.MCP_SERVER_URL,
        }) as MCPTokenPayload;

        // Attach payload to request for downstream use
        (request as any).mcpToken = payload;
      } catch (error) {
        if (error instanceof jwt.TokenExpiredError) {
          return reply.status(401).send({
            error: {
              code: 'TOKEN_EXPIRED',
              message: 'JWT token has expired',
              expiredAt: error.expiredAt,
            },
          });
        }

        if (error instanceof jwt.JsonWebTokenError) {
          return reply.status(401).send({
            error: {
              code: 'INVALID_TOKEN',
              message: 'JWT token is invalid',
              details: error.message,
            },
          });
        }

        // Other errors (e.g., secret not configured)
        console.error('[MCP Auth] Verification error:', error);
        return reply.status(500).send({
          error: {
            code: 'AUTH_ERROR',
            message: 'Authentication failed',
          },
        });
      }
    }
    ```

  - [ ] Export middleware function

- [ ] **Task 4: Create Scope Authorization Middleware** (AC: 2, 4)
  - [ ] In `lib/mcp/auth-middleware.ts`, add `requireScope()` function:

    ```typescript
    export function requireScope(scope: string) {
      return async function (
        request: FastifyRequest,
        reply: FastifyReply,
      ): Promise<void> {
        const token = (request as any).mcpToken as MCPTokenPayload;

        if (!token) {
          return reply.status(401).send({
            error: {
              code: 'UNAUTHORIZED',
              message: 'No valid token found',
            },
          });
        }

        if (!token.scopes.includes(scope)) {
          return reply.status(403).send({
            error: {
              code: 'INSUFFICIENT_SCOPE',
              message: `Required scope: ${scope}`,
              providedScopes: token.scopes,
              requiredScope: scope,
            },
          });
        }
      };
    }
    ```

  - [ ] Export `requireScope` function

- [ ] **Task 5: Integrate Auth Middleware into MCP Server** (AC: 1, 2)
  - [ ] Open `lib/mcp/server.ts`
  - [ ] Import `verifyMCPToken` from auth-middleware
  - [ ] Register middleware globally for all `/mcp/*` routes (except `/mcp/health`):

    ```typescript
    import { verifyMCPToken } from './auth-middleware';

    // Apply auth middleware to all MCP routes except health
    app.addHook('preHandler', async (request, reply) => {
      if (request.url.startsWith('/mcp/') && request.url !== '/mcp/health') {
        await verifyMCPToken(request, reply);
      }
    });
    ```

  - [ ] Test: Health endpoint still accessible without auth
  - [ ] Test: Other endpoints require valid JWT

- [ ] **Task 6: Update Environment Variables** (AC: 1)
  - [ ] Open `.env.example`
  - [ ] Add new environment variables:
    ```bash
    # MCP Server Authentication
    MCP_JWT_SECRET="your-secret-key-here-use-openssl-rand-base64-32"
    MCP_SERVER_URL="http://localhost:4000"  # or https://jive-mcp-staging.railway.app
    NEXT_PUBLIC_WEB_URL="http://localhost:3000"  # JWT issuer
    ```
  - [ ] Document how to generate secret: `openssl rand -base64 32`
  - [ ] Update Railway environment variables with production values

- [ ] **Task 7: Write Unit Tests for Auth Middleware** (AC: 5, 7)
  - [ ] Create `tests/unit/mcp/auth-middleware.test.ts`
  - [ ] Setup test JWT secret and mock environment variables
  - [ ] Write test: `verifyMCPToken accepts valid JWT`
    - [ ] Generate valid JWT with all required fields
    - [ ] Mock Fastify request/reply
    - [ ] Call `verifyMCPToken()`
    - [ ] Assert no error, token payload attached to request
  - [ ] Write test: `verifyMCPToken rejects missing token`
    - [ ] Mock request with no Authorization header
    - [ ] Call middleware
    - [ ] Assert 401 response with MISSING_TOKEN error
  - [ ] Write test: `verifyMCPToken rejects expired JWT`
    - [ ] Generate JWT with exp in the past
    - [ ] Call middleware
    - [ ] Assert 401 response with TOKEN_EXPIRED error
  - [ ] Write test: `verifyMCPToken rejects invalid signature`
    - [ ] Generate JWT signed with different secret
    - [ ] Call middleware
    - [ ] Assert 401 response with INVALID_TOKEN error
  - [ ] Write test: `requireScope allows request with correct scope`
    - [ ] Mock request with token containing 'mcp:status.read'
    - [ ] Call `requireScope('mcp:status.read')`
    - [ ] Assert no error
  - [ ] Write test: `requireScope rejects request with insufficient scope`
    - [ ] Mock request with token missing 'mcp:kanban.write'
    - [ ] Call `requireScope('mcp:kanban.write')`
    - [ ] Assert 403 response with INSUFFICIENT_SCOPE error

- [ ] **Task 8: Write Integration Test** (AC: 6, 7)
  - [ ] Create `tests/integration/mcp/auth.test.ts`
  - [ ] Setup test MCP server with auth middleware
  - [ ] Create helper function `generateTestJWT(scopes: string[])`
  - [ ] Write test: `GET /mcp/health does not require auth`
    - [ ] Make request without Authorization header
    - [ ] Assert 200 response
  - [ ] Write test: `Protected endpoint requires valid JWT`
    - [ ] Make request to `/mcp/tools` without token
    - [ ] Assert 401 response
    - [ ] Make request with valid token
    - [ ] Assert 200 response
  - [ ] Write test: `Protected endpoint rejects expired JWT`
    - [ ] Generate expired JWT
    - [ ] Make request to `/mcp/tools`
    - [ ] Assert 401 response with TOKEN_EXPIRED

- [ ] **Task 9: Create JWT Generation Utility (Testing Only)** (AC: 5, 6)
  - [ ] Create `lib/mcp/test-utils/generate-token.ts`
  - [ ] Implement `generateMCPToken()` function:

    ```typescript
    import jwt from 'jsonwebtoken';
    import { MCPTokenPayload } from '../types/jwt';

    export function generateMCPToken(
      options: {
        sub?: string;
        scopes?: string[];
        actorType?: MCPTokenPayload['actorType'];
        actorName?: string;
        expiresIn?: string | number;
      } = {},
    ): string {
      const payload: Omit<MCPTokenPayload, 'iat' | 'exp'> = {
        sub: options.sub || 'test-agent-123',
        iss: process.env.NEXT_PUBLIC_WEB_URL || 'http://localhost:3000',
        aud: process.env.MCP_SERVER_URL || 'http://localhost:4000',
        scopes: options.scopes || Object.values(MCP_SCOPES),
        actorType: options.actorType || 'ide_agent',
        actorName: options.actorName || 'Test IDE Agent',
      };

      const secret = process.env.MCP_JWT_SECRET || 'test-secret';

      return jwt.sign(payload, secret, {
        expiresIn: options.expiresIn || '1h',
      });
    }
    ```

  - [ ] Export function for use in tests
  - [ ] Document that this is for testing only (not production)

- [ ] **Task 10: Update MCP Deployment Configuration** (AC: all)
  - [ ] Open `railway.mcp.json` (or Railway dashboard)
  - [ ] Add environment variables:
    - `MCP_JWT_SECRET` (generate via `openssl rand -base64 32`)
    - `MCP_SERVER_URL` (Railway-provided URL)
    - `NEXT_PUBLIC_WEB_URL` (web service URL)
  - [ ] Verify variables set in Railway dashboard
  - [ ] Test deployment with auth enabled

- [ ] **Task 11: Verify All Tests Pass** (AC: 7)
  - [ ] Run unit tests: `pnpm test tests/unit/mcp/auth-middleware.test.ts`
  - [ ] Run integration tests: `pnpm test tests/integration/mcp/auth.test.ts`
  - [ ] Verify all tests pass
  - [ ] Run `pnpm type-check` to ensure no TypeScript errors
  - [ ] Run `pnpm lint` to ensure no linting errors

## Dev Notes

### Previous Story Insights

**[From Story 2.1, 2.2]**

Key context from previous stories:

1. **Database Setup:** Story 2.1 created `mcp_audit_logs` table. Story 2.3a will prepare authentication; Story 2.3b will implement audit logging.

2. **MCP Server:** Story 2.2 created Fastify HTTP server on port 4000. Story 2.3a adds authentication middleware to all routes except `/mcp/health`.

3. **Environment Variables:** Story 2.1 configured `DATABASE_URL` and `REDIS_URL`. Story 2.3a adds `MCP_JWT_SECRET`, `MCP_SERVER_URL`, `NEXT_PUBLIC_WEB_URL`.

### Architecture Context

**[Source: docs/architecture.md#mcp-authentication]**

#### JWT Authentication Flow (lines 715-780)

**Token Structure:**

```json
{
  "sub": "cursor-agent-abc123",
  "iss": "https://jive-dashboard-production.railway.app",
  "aud": "https://jive-mcp-production.railway.app",
  "scopes": ["mcp:status.read", "mcp:conflicts.read", "mcp:kanban.write"],
  "actorType": "ide_agent",
  "actorName": "Cursor IDE",
  "iat": 1729996400,
  "exp": 1730000000
}
```

**Verification Steps:**

1. Extract token from `Authorization: Bearer <token>` header
2. Verify signature using `MCP_JWT_SECRET`
3. Verify issuer matches `NEXT_PUBLIC_WEB_URL`
4. Verify audience matches `MCP_SERVER_URL`
5. Verify token not expired (`exp` > current time)
6. Attach payload to request for scope checks

**[Source: docs/architecture.md#scope-based-authorization]**

#### Scope-Based RBAC (lines 781-820)

**Scope Naming Convention:**

- Format: `mcp:<resource>.<action>`
- Examples: `mcp:status.read`, `mcp:kanban.write`, `mcp:gates.read`

**Authorization Flow:**

1. Tool handler specifies required scope (e.g., `mcp:status.read`)
2. Middleware checks if JWT contains required scope
3. If scope present → allow request
4. If scope missing → return 403 with required scope in error

**Error Response Format:**

```json
{
  "error": {
    "code": "INSUFFICIENT_SCOPE",
    "message": "Required scope: mcp:kanban.write",
    "providedScopes": ["mcp:status.read", "mcp:conflicts.read"],
    "requiredScope": "mcp:kanban.write"
  }
}
```

**[Source: docs/architecture.md#mcp-security-requirements]**

#### Security Requirements (lines 1088-1120)

**Critical Security Rules:**

1. **Constant-Time Comparison:** Use `crypto.timingSafeEqual()` for secret validation (prevents timing attacks) - Note: jsonwebtoken library handles this internally
2. **Secret Rotation:** MCP_JWT_SECRET should be rotated quarterly (future enhancement)
3. **Token Expiration:** Default 1 hour, max 24 hours
4. **HTTPS Only:** Production must use HTTPS (Railway provides this automatically)
5. **No Token in Logs:** Never log full JWT token (only token ID or last 4 chars)

**JWT Secret Generation:**

```bash
# Generate strong 256-bit secret
openssl rand -base64 32
```

**Health Endpoint Exception:**

`GET /mcp/health` must be accessible without authentication for Railway health checks and monitoring.

### Testing Strategy

**[Source: docs/architecture.md#testing-strategy]**

**Unit Test Requirements for Story 2.3a:**

- **Coverage Target:** >90% for auth-middleware.ts
- **Test Categories:**
  1. Valid JWT: Token with correct signature, issuer, audience, not expired
  2. Invalid Signature: Token signed with different secret
  3. Expired Token: Token with exp < current time
  4. Missing Token: No Authorization header
  5. Malformed Token: Invalid JWT format
  6. Scope Checks: Token with/without required scope

**Mock Patterns for Auth Tests:**

```typescript
// Mock Fastify request
const mockRequest = {
  headers: {
    authorization: 'Bearer <jwt-token>',
  },
  url: '/mcp/tools',
} as FastifyRequest;

// Mock Fastify reply
const mockReply = {
  status: vi.fn().mockReturnThis(),
  send: vi.fn(),
} as any as FastifyReply;

// Mock environment variables
process.env.MCP_JWT_SECRET = 'test-secret';
process.env.MCP_SERVER_URL = 'http://localhost:4000';
process.env.NEXT_PUBLIC_WEB_URL = 'http://localhost:3000';
```

### Tech Stack Additions

**New Dependencies for Story 2.3a:**

| Dependency          | Version | Purpose                      | Rationale                                    |
| ------------------- | ------- | ---------------------------- | -------------------------------------------- |
| jsonwebtoken        | 9+      | JWT signing and verification | Industry-standard library for JWT operations |
| @types/jsonwebtoken | latest  | TypeScript types for JWT     | Type safety for JWT operations               |

**Installation Commands:**

```bash
pnpm add jsonwebtoken
pnpm add -D @types/jsonwebtoken
```

### File Locations

**New Files Created in Story 2.3a:**

```
jive/
├── lib/
│   └── mcp/
│       ├── types/
│       │   └── jwt.ts                  # NEW - JWT payload types and scopes
│       ├── auth-middleware.ts          # NEW - JWT verification + scope authorization
│       └── test-utils/
│           └── generate-token.ts       # NEW - Test JWT generation utility
├── tests/
│   ├── unit/
│   │   └── mcp/
│   │       └── auth-middleware.test.ts # NEW - Unit tests for auth
│   └── integration/
│       └── mcp/
│           └── auth.test.ts            # NEW - Integration tests for auth flow
└── .env.example                        # UPDATE - Add JWT environment variables
```

**Modified Files:**

```
lib/mcp/server.ts                       # UPDATE - Add auth middleware hook
```

### Coding Standards

**[Source: docs/architecture.md#coding-standards]**

**Critical Rules for Story 2.3a:**

1. **Error Handling:** Always return structured errors with code + message:

   ```typescript
   return reply.status(401).send({
     error: {
       code: 'TOKEN_EXPIRED',
       message: 'JWT token has expired',
     },
   });
   ```

2. **Type Safety:** Use Prisma-generated types and custom JWT types:

   ```typescript
   import { MCPTokenPayload } from './types/jwt';
   const token = (request as any).mcpToken as MCPTokenPayload;
   ```

3. **Logging:** Never log sensitive data (tokens, secrets):

   ```typescript
   // Bad
   console.log('Token:', token);

   // Good
   console.log('[MCP Auth] Token verified for actor:', payload.actorName);
   ```

4. **Middleware Pattern:** Use Fastify's async/await pattern:
   ```typescript
   export async function verifyMCPToken(
     request: FastifyRequest,
     reply: FastifyReply,
   ): Promise<void> {
     // Middleware implementation
   }
   ```

### Deployment Strategy

**[Source: docs/architecture.md#deployment-architecture]**

**Railway Deployment for Story 2.3a:**

- **New Environment Variables:**
  - `MCP_JWT_SECRET`: Generate via `openssl rand -base64 32`, add to Railway
  - `MCP_SERVER_URL`: Railway-provided URL (e.g., `https://jive-mcp-staging.railway.app`)
  - `NEXT_PUBLIC_WEB_URL`: Web service URL (e.g., `https://jive-staging.railway.app`)

- **Deployment Steps:**
  1. Add environment variables to Railway dashboard
  2. Deploy MCP service (triggers rebuild)
  3. Verify health endpoint still accessible: `curl https://jive-mcp-staging.railway.app/mcp/health`
  4. Test protected endpoint without token (should return 401)
  5. Generate test JWT and verify protected endpoint works

**Security Checklist:**

- [ ] MCP_JWT_SECRET is 256-bit random value (32 bytes base64)
- [ ] MCP_JWT_SECRET is stored in Railway secrets (not committed to git)
- [ ] HTTPS enforced in production (Railway default)
- [ ] Health endpoint accessible without auth
- [ ] All other endpoints require valid JWT

### Relationship to Story 2.3b

**Story 2.3a Foundation for Story 2.3b:**

Story 2.3a provides authentication infrastructure that Story 2.3b builds upon:

- JWT payload includes `actorType`, `actorName`, `sub` → used by audit logger
- Auth middleware attaches token to request → accessed by rate limiter and audit logger
- Scope authorization pattern → reused by rate limiter for scope-specific limits

**Story 2.3b Dependencies:**

- Requires `MCPTokenPayload` type from Story 2.3a
- Requires `verifyMCPToken` middleware from Story 2.3a
- Extends middleware chain: auth → rate limit → audit → tool handler

## Change Log

| Date       | Version | Description                                          | Author |
| ---------- | ------- | ---------------------------------------------------- | ------ |
| 2025-10-25 | 1.0     | Story split from 2.3 for focused auth implementation | SM Bob |

## Dev Agent Record

### Agent Model Used

_To be filled by Dev Agent_

### Debug Log References

_To be filled by Dev Agent_

### Completion Notes

_To be filled by Dev Agent_

### File List

_To be filled by Dev Agent_

## QA Results

_To be filled by QA Agent after implementation_
