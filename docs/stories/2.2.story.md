# Story 2.2: Initialize MCP Server Service

## Status

Draft

## Story

**As a** Developer,
**I want** a standalone MCP server running on Railway as a separate service,
**so that** IDE agents (Cursor/Codex) can securely invoke JIVE tools via HTTPS.

## Acceptance Criteria

1. Node.js HTTP server created in `lib/mcp/server.ts` (Express or Fastify)
2. Health endpoint `GET /mcp/health` returns 200 with `{ status: 'ok', service: 'mcp', version }`
3. Railway deployment configured for MCP service (port 4000)
4. `railway.json` updated for multi-service deployment
5. MCP service accessible at `https://jive-mcp-staging.railway.app/health`
6. CORS configured to allow localhost (dev) and web service domain (prod)
7. Basic middleware: logging, error handling, request ID generation
8. Build script added to package.json: `pnpm build:mcp`
9. Start script added: `pnpm start:mcp`
10. All tests pass (`pnpm test`)

## Tasks / Subtasks

- [ ] **Task 1: Install MCP Server Dependencies** (AC: 1, 6)
  - [ ] Install Express or Fastify: `pnpm add fastify` (Fastify recommended for HTTP/2 support)
  - [ ] Install CORS middleware: `pnpm add @fastify/cors`
  - [ ] Install types: `pnpm add -D @types/node`
  - [ ] Verify package.json includes dependencies
  - [ ] Run `pnpm type-check` to ensure no errors

- [ ] **Task 2: Create MCP Server Entry Point** (AC: 1, 2, 7)
  - [ ] Create `lib/mcp/server.ts` file
  - [ ] Import Fastify and create app instance:

    ```typescript
    import Fastify from 'fastify';
    import cors from '@fastify/cors';

    const app = Fastify({ logger: true });
    await app.register(cors, {
      origin:
        process.env.NODE_ENV === 'production'
          ? [process.env.WEB_SERVICE_URL]
          : ['http://localhost:3000'],
    });
    ```

  - [ ] Add request ID middleware:
    ```typescript
    app.addHook('onRequest', async (request, reply) => {
      request.id = crypto.randomUUID();
    });
    ```
  - [ ] Add global error handler:
    ```typescript
    app.setErrorHandler((error, request, reply) => {
      app.log.error(error);
      reply.status(500).send({
        error: {
          code: 'INTERNAL_ERROR',
          message: error.message,
          requestId: request.id,
        },
      });
    });
    ```
  - [ ] Implement health endpoint:
    ```typescript
    app.get('/mcp/health', async (request, reply) => {
      return {
        status: 'ok',
        service: 'mcp',
        version: process.env.npm_package_version,
      };
    });
    ```
  - [ ] Add server startup logic:
    ```typescript
    const PORT = process.env.MCP_PORT || 4000;
    app.listen({ port: PORT, host: '0.0.0.0' }, (err, address) => {
      if (err) {
        app.log.error(err);
        process.exit(1);
      }
      app.log.info(`MCP server listening at ${address}`);
    });
    ```

- [ ] **Task 3: Configure Railway Multi-Service Deployment** (AC: 3, 4)
  - [ ] Update `railway.json` to support multiple services (web, mcp, orchestrator):
    ```json
    {
      "$schema": "https://railway.app/railway.schema.json",
      "services": {
        "web": {
          "build": { "builder": "NIXPACKS", "buildCommand": "pnpm build" },
          "deploy": {
            "startCommand": "pnpm start",
            "healthcheckPath": "/api/health"
          }
        },
        "mcp": {
          "build": { "builder": "NIXPACKS", "buildCommand": "pnpm build:mcp" },
          "deploy": {
            "startCommand": "pnpm start:mcp",
            "healthcheckPath": "/mcp/health"
          }
        }
      }
    }
    ```
  - [ ] OR: Create separate `railway.mcp.json` file for MCP service config
  - [ ] Railway Dashboard: Create new service "jive-mcp" linked to same GitHub repo
  - [ ] Configure environment variables for MCP service in Railway dashboard

- [ ] **Task 4: Add Build and Start Scripts** (AC: 8, 9)
  - [ ] Open `package.json`
  - [ ] Add MCP build script:
    ```json
    "build:mcp": "tsc lib/mcp/server.ts --outDir dist/mcp --module commonjs --target ES2020"
    ```
  - [ ] Add MCP start script:
    ```json
    "start:mcp": "node dist/mcp/server.js"
    ```
  - [ ] Add dev script for local MCP server:
    ```json
    "dev:mcp": "tsx watch lib/mcp/server.ts"
    ```
  - [ ] Test local MCP server: `pnpm dev:mcp`
  - [ ] Verify health endpoint: `curl http://localhost:4000/mcp/health`

- [ ] **Task 5: Configure Environment Variables** (AC: 6)
  - [ ] Open `.env.example`
  - [ ] Add MCP-specific variables:
    ```bash
    # MCP Server
    MCP_PORT=4000
    WEB_SERVICE_URL=https://jive-staging.up.railway.app  # For CORS in production
    ```
  - [ ] Update README.md with MCP service setup instructions
  - [ ] Add `.env.local` entry for local development

- [ ] **Task 6: Write Integration Tests** (AC: 5, 10)
  - [ ] Create `tests/integration/mcp/health.test.ts`
  - [ ] Write test: `MCP health endpoint returns 200`
    - [ ] Start MCP server in test setup
    - [ ] Call `GET /mcp/health`
    - [ ] Assert response status 200
    - [ ] Assert response body contains `{ status: 'ok', service: 'mcp' }`
    - [ ] Cleanup: stop server
  - [ ] Write test: `CORS headers allow web service domain`
    - [ ] Send request with Origin header
    - [ ] Assert Access-Control-Allow-Origin header present
  - [ ] Run `pnpm test tests/integration/mcp/` to execute tests

- [ ] **Task 7: Deploy MCP Service to Railway** (AC: 3, 5)
  - [ ] Push code to GitHub (staging branch)
  - [ ] Railway Dashboard: Verify "jive-mcp" service detected
  - [ ] Configure Railway environment variables:
    - `MCP_PORT=4000`
    - `WEB_SERVICE_URL=https://jive-staging.up.railway.app`
    - `DATABASE_URL` (auto-injected by Railway)
    - `REDIS_URL` (auto-injected by Railway)
  - [ ] Trigger Railway deployment
  - [ ] Wait for build and deploy to complete
  - [ ] Access MCP service URL from Railway dashboard (e.g., `https://jive-mcp-staging.up.railway.app`)
  - [ ] Test health endpoint: `curl https://jive-mcp-staging.up.railway.app/mcp/health`
  - [ ] Verify response: `{ status: 'ok', service: 'mcp', version: '0.1.2' }`

- [ ] **Task 8: Verify Multi-Service Architecture** (AC: 3, 4)
  - [ ] Verify both services running in Railway:
    - Web service: `https://jive-staging.up.railway.app/api/health`
    - MCP service: `https://jive-mcp-staging.up.railway.app/mcp/health`
  - [ ] Check Railway logs for both services
  - [ ] Verify no deployment errors or crashes
  - [ ] Test CORS from web service to MCP (optional - manual browser test)

- [ ] **Task 9: Verify Build and Type Safety** (AC: 10)
  - [ ] Run `pnpm type-check` to verify no TypeScript errors
  - [ ] Run `pnpm lint` to verify no linting errors
  - [ ] Run `pnpm build` and `pnpm build:mcp` to verify both builds succeed
  - [ ] Run `pnpm test` to verify all tests pass
  - [ ] Verify pre-commit hooks work

## Dev Notes

### Previous Story Insights

**[From Story 2.1 Dev Agent Record]**

Key learnings from Story 2.1:

1. **Railway Multi-Service:** Story 2.1 provisioned Postgres/Redis. Story 2.2 adds MCP service as 2nd service (web is 1st).

2. **Environment Variables:** Railway auto-injects `DATABASE_URL` and `REDIS_URL` to all services. MCP server can access shared database.

3. **Build Scripts:** Web service uses `pnpm build` (Next.js). MCP service needs separate TypeScript build (`pnpm build:mcp`).

4. **Port Configuration:** Web (3000), MCP (4000), Orchestrator (no port - background worker).

### Architecture Context

**[Source: docs/architecture.md#high-level-architecture]**

#### Three-Service Architecture (lines 52-75)

**JIVE runs as three Railway services:**

1. **Web App** (Next.js 14):
   - SSR UI, REST API, WebSocket
   - Port 3000

2. **Orchestrator Worker** (Node.js):
   - Background job processor (BullMQ)
   - No public port

3. **MCP Server** (HTTP transport): ← **Story 2.2 implements this**
   - Secure, multi-tenant Model Context Protocol server
   - Exposes JIVE tools to IDE agents (Cursor, Codex)
   - Port 4000
   - HTTPS transport with TLS 1.3
   - Authentication: JWT (OAuth2) or mutual-TLS (enterprise)
   - Tools: status.get, conflicts.list, kanban.moveStory, gates.list, runs.list

**[Source: docs/architecture.md#components]**

#### MCP Server Components (lines 871-919)

**MCPServer Service (Story 2.2 creates foundation):**

**Responsibility:** Expose MCP tools to IDE agents with authentication and audit logging

**Technology:** Fastify (HTTP/2 support), JWT verification, Redis rate limiting

**Key Components (implemented across Stories 2.2-2.4):**

- **Story 2.2:** HTTP server, health endpoint, CORS, error handling
- **Story 2.3:** Auth middleware, rate limiter, audit logger
- **Story 2.4:** Tool registry, tool handlers (5 tools)

**Endpoints:**

- `GET /mcp/health` - Health check (Story 2.2)
- `GET /mcp/tools` - Tool discovery (Story 2.4)
- `POST /mcp/invoke` - Tool invocation (Story 2.4)

**[Source: docs/architecture.md#platform-and-infrastructure-choice]**

#### Railway Deployment (lines 96-120)

**MCP Service Configuration:**

```yaml
Service: mcp (Node.js HTTP server)
Build Command: pnpm build:mcp
Start Command: node dist/mcp/server.js
Port: 4000
Scaling: Horizontal (stateless)
Health Check: GET /mcp/health
```

**Railway Multi-Service Pattern:**

- **Shared Resources:** Postgres, Redis (auto-injected to all services)
- **Isolation:** Each service has independent build/deploy
- **Networking:** Services communicate via shared DB or Redis pub/sub

### Testing Strategy

**Integration Test Requirements for Story 2.2:**

- **Framework:** Vitest with server startup in beforeAll()
- **Test Categories:**
  1. Health endpoint returns 200
  2. CORS headers configured correctly
  3. Error handling returns standardized format
  4. Request ID generated for each request

**Example Integration Test:**

```typescript
// tests/integration/mcp/health.test.ts
import { describe, test, expect, beforeAll, afterAll } from 'vitest';
import { FastifyInstance } from 'fastify';
import { createMCPServer } from '@/lib/mcp/server';

describe('MCP Server Health', () => {
  let server: FastifyInstance;

  beforeAll(async () => {
    server = await createMCPServer();
    await server.listen({ port: 4001 }); // Use different port for tests
  });

  afterAll(async () => {
    await server.close();
  });

  test('health endpoint returns 200', async () => {
    const response = await server.inject({
      method: 'GET',
      url: '/mcp/health',
    });

    expect(response.statusCode).toBe(200);
    const body = JSON.parse(response.body);
    expect(body.status).toBe('ok');
    expect(body.service).toBe('mcp');
  });
});
```

### Tech Stack Additions

**New Dependencies for Story 2.2:**

| Dependency    | Version | Purpose                           | Rationale                                      |
| ------------- | ------- | --------------------------------- | ---------------------------------------------- |
| fastify       | 5+      | HTTP framework for MCP server     | HTTP/2 support, fast, TypeScript-friendly      |
| @fastify/cors | 10+     | CORS middleware for Fastify       | Allow web service and localhost to call MCP    |
| tsx           | 4+      | TypeScript execution for dev mode | Run `lib/mcp/server.ts` directly without build |

**Installation Commands:**

```bash
pnpm add fastify @fastify/cors
pnpm add -D tsx
```

**Note:** Express is alternative to Fastify, but Fastify chosen for HTTP/2 support (architecture line 115).

### File Locations

**New Files Created in Story 2.2:**

```
jive/
├── lib/
│   └── mcp/
│       └── server.ts              # NEW - MCP HTTP server entry point
├── tests/
│   └── integration/
│       └── mcp/
│           └── health.test.ts     # NEW - MCP health endpoint tests
├── dist/
│   └── mcp/
│       └── server.js              # GENERATED - Compiled MCP server
├── .env.example                   # UPDATE - Add MCP_PORT, WEB_SERVICE_URL
├── package.json                   # UPDATE - Add build:mcp, start:mcp scripts
└── railway.json                   # UPDATE - Multi-service config
```

### Coding Standards

**[Source: docs/architecture.md#coding-standards]**

**Critical Rules for Story 2.2:**

1. **Server Factory Pattern:** Export factory function for testability:

   ```typescript
   export async function createMCPServer() {
     const app = Fastify({ logger: true });
     // ... configure middleware
     return app;
   }
   ```

2. **Error Handling:** Standardized error format (matches web service):

   ```typescript
   interface ApiError {
     error: {
       code: string;
       message: string;
       details?: Record<string, any>;
       timestamp: string;
       requestId: string;
     };
   }
   ```

3. **Logging:** Use Fastify's built-in logger (Pino):

   ```typescript
   app.log.info('MCP server started');
   app.log.error({ err: error }, 'Request failed');
   ```

4. **Environment Variables:** Never hardcode URLs or ports:
   ```typescript
   const PORT = parseInt(process.env.MCP_PORT || '4000', 10);
   ```

### Deployment Strategy

**Railway Multi-Service Deployment:**

**Option 1: Single railway.json with services field:**

```json
{
  "services": {
    "web": { "buildCommand": "pnpm build", "startCommand": "pnpm start" },
    "mcp": {
      "buildCommand": "pnpm build:mcp",
      "startCommand": "pnpm start:mcp"
    }
  }
}
```

**Option 2: Separate Railway services (recommended):**

1. Railway Dashboard → New Service → "jive-mcp"
2. Link to same GitHub repo
3. Configure build/start commands in Railway UI
4. Set environment variables per service

**Recommendation:** Use Option 2 for independent deployment control.

**Railway Environment Variables (MCP Service):**

```bash
MCP_PORT=4000
WEB_SERVICE_URL=https://jive-staging.up.railway.app
DATABASE_URL=postgresql://... # Auto-injected by Railway
REDIS_URL=redis://...         # Auto-injected by Railway
NODE_ENV=production
```

### Security Considerations

**[Source: docs/architecture.md#security-requirements]**

**MCP Server Security (Story 2.2 scope):**

1. **CORS Configuration:**
   - Development: Allow `http://localhost:3000`
   - Production: Allow web service domain only (`WEB_SERVICE_URL`)
   - Block all other origins

2. **HTTPS Enforcement:**
   - Railway provides TLS 1.3 automatically
   - HTTP requests redirected to HTTPS

3. **Error Handling:**
   - Never expose stack traces in production
   - Use generic error messages for 500 errors
   - Log full errors server-side

4. **Request ID:**
   - Generate UUID for each request
   - Include in error responses for debugging
   - Log all requests with request ID

**Note:** Authentication (JWT) and rate limiting added in Story 2.3.

### Relationship to Future Stories

**Story 2.2 Foundation for:**

- **Story 2.3:** Adds JWT auth middleware to MCP server
- **Story 2.4:** Adds tool registry and 5 MCP tools to MCP server
- **Story 2.5:** Orchestrator worker (separate service)

**Expected Server Evolution:**

```
Story 2.2: MCP Server
    ↓ Health endpoint only

Story 2.3: Add Auth Middleware
    ↓ JWT verification, rate limiting, audit logging

Story 2.4: Add Tool Endpoints
    ↓ /mcp/tools, /mcp/invoke with 5 tools
    ↓ Cursor/Codex can invoke tools

Future: Add More Tools
    ↓ artifact.update, conflict.resolve, gate.override
```

### Performance Considerations

**Fastify Performance:**

- HTTP/2 support reduces latency for multiple concurrent requests
- Built-in JSON schema validation (added in Story 2.4)
- Request/response serialization optimized
- No performance tuning needed in Story 2.2

**Health Endpoint:**

- Lightweight endpoint (no DB queries)
- Used by Railway for health checks
- Target response time: <10ms

### Example MCP Server Code

**lib/mcp/server.ts (Story 2.2 implementation):**

```typescript
import Fastify from 'fastify';
import cors from '@fastify/cors';
import crypto from 'crypto';

export async function createMCPServer() {
  const app = Fastify({
    logger: {
      level: process.env.LOG_LEVEL || 'info',
    },
  });

  // CORS
  await app.register(cors, {
    origin:
      process.env.NODE_ENV === 'production'
        ? [process.env.WEB_SERVICE_URL as string]
        : ['http://localhost:3000'],
  });

  // Request ID middleware
  app.addHook('onRequest', async (request) => {
    (request as any).id = crypto.randomUUID();
  });

  // Global error handler
  app.setErrorHandler((error, request, reply) => {
    app.log.error(
      { err: error, requestId: (request as any).id },
      'Request failed',
    );
    reply.status(500).send({
      error: {
        code: 'INTERNAL_ERROR',
        message:
          process.env.NODE_ENV === 'production'
            ? 'Internal server error'
            : error.message,
        requestId: (request as any).id,
        timestamp: new Date().toISOString(),
      },
    });
  });

  // Health endpoint
  app.get('/mcp/health', async () => {
    return {
      status: 'ok',
      service: 'mcp',
      version: process.env.npm_package_version || '0.1.0',
      timestamp: new Date().toISOString(),
    };
  });

  return app;
}

// Entry point
if (require.main === module) {
  const PORT = parseInt(process.env.MCP_PORT || '4000', 10);

  createMCPServer().then((app) => {
    app.listen({ port: PORT, host: '0.0.0.0' }, (err, address) => {
      if (err) {
        app.log.error(err);
        process.exit(1);
      }
      app.log.info(`MCP server listening at ${address}`);
    });
  });
}
```

## Change Log

| Date       | Version | Description                         | Author |
| ---------- | ------- | ----------------------------------- | ------ |
| 2025-10-15 | 1.0     | Story created for Epic 2 MCP server | SM Bob |

## Dev Agent Record

### Agent Model Used

_To be filled by Dev Agent_

### Debug Log References

_To be filled by Dev Agent_

### Completion Notes

_To be filled by Dev Agent_

### File List

_To be filled by Dev Agent_

## QA Results

_To be filled by QA Agent after implementation_
