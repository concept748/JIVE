# Story 2.3: MCP Authentication & Authorization

## Status

Draft

## Story

**As a** Security Engineer,
**I want** MCP tool invocations authenticated and authorized via JWT with scopes,
**so that** only authorized IDE agents can access JIVE data and audit trails capture all access attempts.

## Acceptance Criteria

1. JWT verification middleware created (verifies signature, expiry, issuer)
2. Scope-based RBAC implemented (mcp:status.read, mcp:conflicts.read, mcp:kanban.write, etc.)
3. Rate limiting via Redis token bucket (60 requests/minute per client)
4. Audit logging to `mcp_audit_logs` table (actor, tool, scope, result, timestamp)
5. Unauthorized requests return 401 with error details
6. Rate-limited requests return 429 with `Retry-After` header
7. Unit tests for auth middleware (valid/invalid tokens, expired tokens, scope checks)
8. Integration test: MCP tool call with valid JWT succeeds, invalid JWT fails
9. All tests pass (`pnpm test`)

## Tasks / Subtasks

- [ ] **Task 1: Install Authentication Dependencies** (AC: 1, 3)
  - [ ] Install jsonwebtoken: `pnpm add jsonwebtoken`
  - [ ] Install types: `pnpm add -D @types/jsonwebtoken`
  - [ ] Install Fastify JWT plugin: `pnpm add @fastify/jwt`
  - [ ] Verify package.json includes all dependencies
  - [ ] Run `pnpm type-check` to ensure no errors

- [ ] **Task 2: Define JWT Schema & Types** (AC: 1, 2)
  - [ ] Create `lib/mcp/types/jwt.ts` file
  - [ ] Define `MCPTokenPayload` interface:
    ```typescript
    export interface MCPTokenPayload {
      sub: string; // Actor ID (user ID or service account ID)
      name: string; // Actor name
      type: 'user' | 'service_account';
      iss: string; // Issuer (web service URL)
      aud: string; // Audience ('mcp-server')
      exp: number; // Expiry timestamp
      iat: number; // Issued at timestamp
      scopes: string[]; // Array of scope strings
      projectIds?: string[]; // Optional: limit token to specific projects
    }
    ```
  - [ ] Define scope constants:
    ```typescript
    export const MCP_SCOPES = {
      STATUS_READ: 'mcp:status.read',
      CONFLICTS_READ: 'mcp:conflicts.read',
      KANBAN_WRITE: 'mcp:kanban.write',
      GATES_READ: 'mcp:gates.read',
      RUNS_READ: 'mcp:runs.read',
    } as const;
    ```
  - [ ] Export type: `type MCPScope = typeof MCP_SCOPES[keyof typeof MCP_SCOPES]`

- [ ] **Task 3: Create JWT Verification Middleware** (AC: 1, 5)
  - [ ] Create `lib/mcp/auth-middleware.ts` file
  - [ ] Import `@fastify/jwt` and `MCPTokenPayload` type
  - [ ] Create `verifyMCPToken()` Fastify hook:

    ```typescript
    import { FastifyRequest, FastifyReply } from 'fastify';
    import jwt from 'jsonwebtoken';
    import { MCPTokenPayload } from './types/jwt';

    export async function verifyMCPToken(
      request: FastifyRequest,
      reply: FastifyReply,
    ) {
      const authHeader = request.headers.authorization;

      if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return reply.status(401).send({
          error: {
            code: 'MISSING_TOKEN',
            message: 'Missing or invalid Authorization header',
            timestamp: new Date().toISOString(),
          },
        });
      }

      const token = authHeader.substring(7); // Remove 'Bearer '
      const secret = process.env.MCP_JWT_SECRET;

      if (!secret) {
        throw new Error('MCP_JWT_SECRET not configured');
      }

      try {
        const decoded = jwt.verify(token, secret, {
          issuer: process.env.WEB_SERVICE_URL,
          audience: 'mcp-server',
        }) as MCPTokenPayload;

        // Attach decoded token to request
        (request as any).mcpToken = decoded;
      } catch (error) {
        const errorCode =
          error instanceof jwt.TokenExpiredError
            ? 'TOKEN_EXPIRED'
            : error instanceof jwt.JsonWebTokenError
              ? 'INVALID_TOKEN'
              : 'VERIFICATION_FAILED';

        return reply.status(401).send({
          error: {
            code: errorCode,
            message:
              error instanceof Error
                ? error.message
                : 'Token verification failed',
            timestamp: new Date().toISOString(),
          },
        });
      }
    }
    ```

  - [ ] Export `verifyMCPToken` function

- [ ] **Task 4: Create Scope Authorization Middleware** (AC: 2, 5)
  - [ ] In `lib/mcp/auth-middleware.ts`, create `requireScope()` function:

    ```typescript
    export function requireScope(requiredScope: string) {
      return async (request: FastifyRequest, reply: FastifyReply) => {
        const token = (request as any).mcpToken as MCPTokenPayload;

        if (!token) {
          return reply.status(401).send({
            error: {
              code: 'UNAUTHORIZED',
              message: 'Token not verified (middleware order issue)',
              timestamp: new Date().toISOString(),
            },
          });
        }

        if (!token.scopes.includes(requiredScope)) {
          return reply.status(403).send({
            error: {
              code: 'INSUFFICIENT_SCOPE',
              message: `Required scope: ${requiredScope}`,
              scopes: token.scopes,
              timestamp: new Date().toISOString(),
            },
          });
        }
      };
    }
    ```

  - [ ] Export `requireScope` function

- [ ] **Task 5: Create Rate Limiter** (AC: 3, 6)
  - [ ] Create `lib/mcp/rate-limiter.ts` file
  - [ ] Import Redis client from `@/lib/db/redis`
  - [ ] Implement Token Bucket algorithm:

    ```typescript
    import { redis } from '@/lib/db/redis';
    import { FastifyRequest, FastifyReply } from 'fastify';
    import { MCPTokenPayload } from './types/jwt';

    const RATE_LIMIT_WINDOW = 60; // seconds
    const MAX_REQUESTS = 60;

    export async function rateLimitMCP(
      request: FastifyRequest,
      reply: FastifyReply,
    ) {
      const token = (request as any).mcpToken as MCPTokenPayload;
      if (!token) {
        return; // Skip rate limiting if no token (will be caught by auth middleware)
      }

      const key = `rate_limit:mcp:${token.sub}`;
      const now = Date.now();

      try {
        // Get current bucket state
        const bucketData = await redis.get(key);
        let tokens = MAX_REQUESTS;
        let lastRefill = now;

        if (bucketData) {
          const bucket = JSON.parse(bucketData);
          tokens = bucket.tokens;
          lastRefill = bucket.lastRefill;

          // Refill tokens based on time elapsed
          const elapsed = (now - lastRefill) / 1000;
          const refillAmount = Math.floor(
            elapsed * (MAX_REQUESTS / RATE_LIMIT_WINDOW),
          );
          tokens = Math.min(MAX_REQUESTS, tokens + refillAmount);
          lastRefill = now;
        }

        if (tokens < 1) {
          const retryAfter = Math.ceil(
            RATE_LIMIT_WINDOW - (now - lastRefill) / 1000,
          );
          return reply
            .status(429)
            .headers({
              'Retry-After': retryAfter.toString(),
            })
            .send({
              error: {
                code: 'RATE_LIMITED',
                message: `Rate limit exceeded. Max ${MAX_REQUESTS} requests per ${RATE_LIMIT_WINDOW}s`,
                retryAfter,
                timestamp: new Date().toISOString(),
              },
            });
        }

        // Consume 1 token
        tokens -= 1;
        await redis.set(
          key,
          JSON.stringify({ tokens, lastRefill }),
          'EX',
          RATE_LIMIT_WINDOW,
        );
      } catch (error) {
        console.error('Rate limiter error:', error);
        // Fail open: allow request if Redis is down
      }
    }
    ```

  - [ ] Export `rateLimitMCP` function

- [ ] **Task 6: Create Audit Logger** (AC: 4)
  - [ ] Create `lib/mcp/audit-logger.ts` file
  - [ ] Import Prisma client from `@/lib/db/prisma`
  - [ ] Create `logMCPAudit()` function:

    ```typescript
    import { prisma } from '@/lib/db/prisma';
    import { MCPResult } from '@prisma/client';
    import { MCPTokenPayload } from './types/jwt';
    import crypto from 'crypto';

    export interface MCPAuditLogInput {
      projectId: string;
      token: MCPTokenPayload;
      tool: string;
      scope: string;
      args: any;
      result: MCPResult;
      errorMessage?: string;
      ipAddress: string;
      userAgent: string;
    }

    export async function logMCPAudit(input: MCPAuditLogInput): Promise<void> {
      const argsHash = crypto
        .createHash('sha256')
        .update(JSON.stringify(input.args))
        .digest('hex');

      try {
        await prisma.mCPAuditLog.create({
          data: {
            projectId: input.projectId,
            actorType: input.token.type,
            actorId: input.token.sub,
            actorName: input.token.name,
            tool: input.tool,
            scope: input.scope,
            argsHash,
            result: input.result,
            errorMessage: input.errorMessage,
            ipAddress: input.ipAddress,
            userAgent: input.userAgent,
          },
        });
      } catch (error) {
        console.error('Failed to log MCP audit:', error);
        // Don't throw - audit logging failure shouldn't break MCP requests
      }
    }
    ```

  - [ ] Export `logMCPAudit` function

- [ ] **Task 7: Integrate Middleware into MCP Server** (AC: 1, 2, 3, 4)
  - [ ] Open `lib/mcp/server.ts`
  - [ ] Import auth middleware functions
  - [ ] Register `@fastify/jwt` plugin:

    ```typescript
    import fastifyJwt from '@fastify/jwt';

    await app.register(fastifyJwt, {
      secret: process.env.MCP_JWT_SECRET || 'dev-secret-change-in-production',
    });
    ```

  - [ ] Add global auth hooks (apply to all routes except health):

    ```typescript
    app.addHook('onRequest', async (request, reply) => {
      if (request.url === '/mcp/health') {
        return; // Skip auth for health endpoint
      }
      await verifyMCPToken(request, reply);
    });

    app.addHook('onRequest', async (request, reply) => {
      if (request.url === '/mcp/health') {
        return;
      }
      await rateLimitMCP(request, reply);
    });
    ```

  - [ ] Update health endpoint to remain unauthenticated
  - [ ] Test: `curl http://localhost:4000/mcp/health` (should succeed)
  - [ ] Test: `curl http://localhost:4000/mcp/tools` (should return 401)

- [ ] **Task 8: Update Environment Variables** (AC: 1)
  - [ ] Open `.env.example`
  - [ ] Add `MCP_JWT_SECRET=your-secret-key-min-32-chars`
  - [ ] Add `WEB_SERVICE_URL=https://jive-staging.up.railway.app` (for JWT issuer validation)
  - [ ] Add comment: `# MCP JWT secret - generate with: openssl rand -base64 32`
  - [ ] Create `.env.local` with local values (not committed)

- [ ] **Task 9: Write Unit Tests for Auth Middleware** (AC: 7, 9)
  - [ ] Create `tests/unit/mcp/auth-middleware.test.ts`
  - [ ] Write test: `verifies valid JWT token`
    - [ ] Generate valid JWT with `jsonwebtoken.sign()`
    - [ ] Mock Fastify request with `Authorization: Bearer <token>` header
    - [ ] Call `verifyMCPToken()`
    - [ ] Assert token attached to `request.mcpToken`
  - [ ] Write test: `rejects expired token`
    - [ ] Generate expired JWT (`exp` in the past)
    - [ ] Assert returns 401 with `TOKEN_EXPIRED` code
  - [ ] Write test: `rejects invalid signature`
    - [ ] Generate JWT with wrong secret
    - [ ] Assert returns 401 with `INVALID_TOKEN` code
  - [ ] Write test: `rejects missing Authorization header`
    - [ ] Mock request without header
    - [ ] Assert returns 401 with `MISSING_TOKEN` code
  - [ ] Write test: `requireScope allows matching scope`
    - [ ] Mock request with token containing `mcp:status.read` scope
    - [ ] Call `requireScope('mcp:status.read')`
    - [ ] Assert passes without error
  - [ ] Write test: `requireScope rejects insufficient scope`
    - [ ] Mock request with token missing required scope
    - [ ] Assert returns 403 with `INSUFFICIENT_SCOPE` code

- [ ] **Task 10: Write Unit Tests for Rate Limiter** (AC: 3, 6, 7, 9)
  - [ ] Create `tests/unit/mcp/rate-limiter.test.ts`
  - [ ] Write test: `allows requests within rate limit`
    - [ ] Mock Redis client (in-memory or redis-mock)
    - [ ] Make 60 consecutive requests
    - [ ] Assert all succeed
  - [ ] Write test: `blocks request exceeding rate limit`
    - [ ] Make 61 requests rapidly
    - [ ] Assert 61st request returns 429 with `RATE_LIMITED` code
    - [ ] Assert `Retry-After` header present
  - [ ] Write test: `refills tokens over time`
    - [ ] Exhaust rate limit
    - [ ] Wait 30 seconds (mock time or use fake timers)
    - [ ] Assert ~30 new tokens available
  - [ ] Write test: `fails open when Redis unavailable`
    - [ ] Mock Redis error
    - [ ] Assert request allowed (fail-open strategy)

- [ ] **Task 11: Write Integration Tests** (AC: 8, 9)
  - [ ] Create `tests/integration/mcp/auth.test.ts`
  - [ ] Start MCP server in test environment
  - [ ] Write test: `authenticated request to /mcp/tools succeeds`
    - [ ] Generate valid JWT with all scopes
    - [ ] Make request to `/mcp/tools` with `Authorization` header
    - [ ] Assert returns 200 (or appropriate response)
  - [ ] Write test: `unauthenticated request to /mcp/tools fails`
    - [ ] Make request without `Authorization` header
    - [ ] Assert returns 401
  - [ ] Write test: `invalid token returns 401`
    - [ ] Generate token with wrong secret
    - [ ] Assert returns 401 with `INVALID_TOKEN`
  - [ ] Write test: `rate limit enforced`
    - [ ] Make 61 rapid requests with same token
    - [ ] Assert 61st returns 429
  - [ ] Write test: `audit log created for authenticated request`
    - [ ] Make authenticated request to MCP tool
    - [ ] Query `mcp_audit_logs` table
    - [ ] Assert log entry exists with correct actor, tool, result

- [ ] **Task 12: Create JWT Generation Utility (for Testing)** (AC: 7, 8)
  - [ ] Create `tests/utils/generate-mcp-token.ts`
  - [ ] Export `generateMCPToken()` function:

    ```typescript
    import jwt from 'jsonwebtoken';
    import { MCPTokenPayload } from '@/lib/mcp/types/jwt';

    export function generateMCPToken(
      payload: Partial<MCPTokenPayload>,
      options?: { expiresIn?: string; secret?: string },
    ): string {
      const secret =
        options?.secret || process.env.MCP_JWT_SECRET || 'test-secret';
      const defaultPayload: MCPTokenPayload = {
        sub: 'test-user-id',
        name: 'Test User',
        type: 'user',
        iss: process.env.WEB_SERVICE_URL || 'http://localhost:3000',
        aud: 'mcp-server',
        exp: Math.floor(Date.now() / 1000) + 3600, // 1 hour
        iat: Math.floor(Date.now() / 1000),
        scopes: ['mcp:status.read', 'mcp:conflicts.read'],
        ...payload,
      };

      return jwt.sign(defaultPayload, secret, {
        expiresIn: options?.expiresIn || '1h',
      });
    }
    ```

  - [ ] Use in all unit/integration tests requiring JWT tokens

- [ ] **Task 13: Update MCP Server Deployment** (AC: all)
  - [ ] Verify Railway environment variables set:
    - `MCP_JWT_SECRET` (generate securely: `openssl rand -base64 32`)
    - `WEB_SERVICE_URL` (set to web service URL)
  - [ ] Push Story 2.3 implementation to staging branch
  - [ ] Verify Railway deployment succeeds
  - [ ] Test health endpoint: `curl https://jive-mcp-staging.railway.app/mcp/health`
  - [ ] Test auth endpoint: `curl https://jive-mcp-staging.railway.app/mcp/tools` (should return 401)

- [ ] **Task 14: Verify All Tests Pass** (AC: 9)
  - [ ] Run unit tests: `pnpm test tests/unit/mcp/`
  - [ ] Run integration tests: `pnpm test tests/integration/mcp/auth.test.ts`
  - [ ] Verify test coverage for auth middleware >80%
  - [ ] Run `pnpm type-check` to ensure no TypeScript errors
  - [ ] Run `pnpm lint` to ensure no linting errors

## Dev Notes

### Previous Story Insights

**[From Story 2.1 & 2.2]**

Key context from previous stories:

1. **Prisma Setup:** Story 2.1 created `MCPAuditLog` table for audit logging. Story 2.3 uses Prisma client to persist audit logs.

2. **Redis Setup:** Story 2.1 created Redis client singleton. Story 2.3 uses Redis for token bucket rate limiting.

3. **MCP Server:** Story 2.2 created Fastify HTTP server with health endpoint. Story 2.3 adds authentication middleware to all routes except health.

4. **Middleware Pattern:** Fastify uses `addHook('onRequest', ...)` for global middleware. Story 2.3 applies auth hooks globally with conditional skipping for health endpoint.

### Architecture Context

**[Source: docs/architecture.md#security-requirements]**

#### MCP Authentication Model (lines 1650-1720)

**Authentication Flow:**

1. User logs into web service (GitHub OAuth or email/password)
2. Web service issues JWT with scopes based on user role
3. IDE agent (Cursor/Codex) includes JWT in `Authorization: Bearer <token>` header
4. MCP server verifies JWT signature, expiry, issuer, audience
5. MCP server checks required scope for tool invocation
6. MCP server logs audit entry to `mcp_audit_logs` table
7. Tool executes and returns result

**JWT Payload Structure:**

```typescript
{
  sub: 'user-uuid-or-service-account-id',
  name: 'John Doe',
  type: 'user' | 'service_account',
  iss: 'https://jive-staging.up.railway.app',
  aud: 'mcp-server',
  exp: 1730000000,  // Unix timestamp
  iat: 1729996400,
  scopes: [
    'mcp:status.read',
    'mcp:conflicts.read',
    'mcp:kanban.write',
    'mcp:gates.read',
    'mcp:runs.read'
  ],
  projectIds: ['uuid1', 'uuid2']  // Optional: restrict to specific projects
}
```

**Security Requirements:**

- **JWT Secret:** Minimum 256 bits (32 bytes). Generate with `openssl rand -base64 32`.
- **Token Expiry:** Default 1 hour (`exp` claim). Short-lived for security.
- **Issuer Validation:** MCP server verifies `iss` matches web service URL.
- **Audience Validation:** MCP server verifies `aud` is `'mcp-server'`.
- **Constant-Time Comparison:** JWT library handles signature verification securely.

**[Source: docs/architecture.md#rate-limiting]**

#### Rate Limiting Strategy (lines 1730-1750)

**Token Bucket Algorithm:**

- **Bucket Capacity:** 60 tokens
- **Refill Rate:** 60 tokens per 60 seconds (1 token/second)
- **Per-Client:** Rate limit key is `rate_limit:mcp:{actorId}`
- **Redis TTL:** 60 seconds (auto-expire stale buckets)

**Implementation Details:**

```typescript
// Redis key: rate_limit:mcp:{actorId}
{
  tokens: 45,             // Current tokens available
  lastRefill: 1729996400000  // Last refill timestamp (ms)
}
```

**Refill Logic:**

```typescript
const elapsed = (now - lastRefill) / 1000; // seconds
const refillAmount = Math.floor(elapsed * (maxRequests / windowSeconds));
const newTokens = Math.min(maxTokens, currentTokens + refillAmount);
```

**429 Response:**

```json
{
  "error": {
    "code": "RATE_LIMITED",
    "message": "Rate limit exceeded. Max 60 requests per 60s",
    "retryAfter": 15,
    "timestamp": "2025-10-15T15:30:00Z"
  }
}
```

**Headers:**

```
HTTP/1.1 429 Too Many Requests
Retry-After: 15
```

**[Source: docs/architecture.md#audit-logging]**

#### MCP Audit Logging (lines 1755-1780)

**Audit Log Schema (from Story 2.1):**

```prisma
model MCPAuditLog {
  id           String    @id @default(uuid())
  projectId    String
  actorType    String    // 'user' | 'service_account'
  actorId      String
  actorName    String
  tool         String
  scope        String
  argsHash     String    // SHA-256
  result       MCPResult
  errorMessage String?   @db.Text
  timestamp    DateTime  @default(now())
  ipAddress    String
  userAgent    String    @db.Text

  project      Project   @relation(fields: [projectId], references: [id])

  @@index([projectId, timestamp])
  @@index([actorId, timestamp])
  @@index([tool, timestamp])
}

enum MCPResult {
  SUCCESS
  FAILURE
  UNAUTHORIZED
  RATE_LIMITED
}
```

**Audit Log Strategy:**

- **When to Log:** Every MCP tool invocation (success or failure)
- **Failure Handling:** Audit log failure does NOT fail the MCP request (fail-open)
- **Arguments Hashing:** SHA-256 hash of args JSON to prevent PII leakage in logs
- **IP & User Agent:** Extracted from request headers for forensics

**Example Audit Log Entry:**

```typescript
{
  id: 'uuid',
  projectId: 'project-uuid',
  actorType: 'user',
  actorId: 'user-uuid',
  actorName: 'John Doe',
  tool: 'status.get',
  scope: 'mcp:status.read',
  argsHash: 'sha256-hash-of-args',
  result: 'SUCCESS',
  errorMessage: null,
  timestamp: '2025-10-15T15:30:00Z',
  ipAddress: '192.168.1.1',
  userAgent: 'Cursor IDE/1.0'
}
```

### Testing Strategy

**[Source: docs/architecture.md#testing-strategy]**

**Unit Test Requirements for Story 2.3:**

- **Coverage Target:** >80% for auth middleware, rate limiter, audit logger
- **Test Isolation:** Mock Fastify request/reply objects, Redis client, Prisma client
- **Test Categories:**
  1. JWT Verification: Valid token, expired token, invalid signature, missing header
  2. Scope Authorization: Matching scope, insufficient scope, missing scope
  3. Rate Limiting: Within limit, exceed limit, refill over time, Redis failure (fail-open)
  4. Audit Logging: Success log, failure log, Prisma error handling

**Integration Test Requirements:**

- **Framework:** Vitest with running MCP server
- **Test Database:** Use test Postgres or in-memory SQLite (via Prisma)
- **Test Redis:** Use redis-mock or separate test Redis instance
- **Test Scenarios:**
  1. Full auth flow: Generate JWT → Make request → Verify audit log
  2. Rate limiting: Make 61 requests → Verify 429 response
  3. Invalid token: Make request with bad JWT → Verify 401 response

**Mock Patterns:**

```typescript
// Mock Fastify Request
const mockRequest = {
  headers: { authorization: 'Bearer <token>' },
  url: '/mcp/tools',
  ip: '192.168.1.1',
} as unknown as FastifyRequest;

// Mock Fastify Reply
const mockReply = {
  status: vi.fn().mockReturnThis(),
  send: vi.fn(),
  headers: vi.fn().mockReturnThis(),
} as unknown as FastifyReply;

// Mock Redis Client
vi.mock('@/lib/db/redis', () => ({
  redis: {
    get: vi.fn(),
    set: vi.fn(),
  },
}));

// Mock Prisma Client
vi.mock('@/lib/db/prisma', () => ({
  prisma: {
    mCPAuditLog: {
      create: vi.fn(),
    },
  },
}));
```

### Tech Stack Additions

**New Dependencies for Story 2.3:**

| Dependency          | Version | Purpose                      | Rationale                                              |
| ------------------- | ------- | ---------------------------- | ------------------------------------------------------ |
| jsonwebtoken        | 9+      | JWT signing and verification | Industry-standard JWT library, supports RS256/HS256    |
| @types/jsonwebtoken | 9+      | TypeScript types for jwt     | Type safety for JWT operations                         |
| @fastify/jwt        | 8+      | Fastify JWT plugin           | Fastify-native JWT integration, auto-decorates request |

**Installation Commands:**

```bash
pnpm add jsonwebtoken @fastify/jwt
pnpm add -D @types/jsonwebtoken
```

**Note:** Redis client (`ioredis`) already installed in Story 2.1. Prisma client already available.

### File Locations

**New Files Created in Story 2.3:**

```
jive/
├── lib/
│   └── mcp/
│       ├── types/
│       │   └── jwt.ts                # NEW - JWT payload types, scope constants
│       ├── auth-middleware.ts        # NEW - JWT verification, scope authorization
│       ├── rate-limiter.ts           # NEW - Token bucket rate limiter
│       └── audit-logger.ts           # NEW - MCP audit logging
├── tests/
│   ├── unit/
│   │   └── mcp/
│   │       ├── auth-middleware.test.ts  # NEW - Auth middleware unit tests
│   │       └── rate-limiter.test.ts     # NEW - Rate limiter unit tests
│   ├── integration/
│   │   └── mcp/
│   │       └── auth.test.ts          # NEW - Auth integration tests
│   └── utils/
│       └── generate-mcp-token.ts     # NEW - JWT generation for tests
└── .env.example                       # UPDATE - Add MCP_JWT_SECRET, WEB_SERVICE_URL
```

**Modified Files:**

```
lib/mcp/server.ts  # UPDATE - Register JWT plugin, add auth hooks
```

### Coding Standards

**[Source: docs/architecture.md#coding-standards]**

**Critical Rules for Story 2.3:**

1. **Error Handling:** Auth middleware must use try-catch and return structured errors:

   ```typescript
   try {
     const decoded = jwt.verify(token, secret);
   } catch (error) {
     return reply.status(401).send({
       error: {
         code: 'INVALID_TOKEN',
         message: error.message,
         timestamp: new Date().toISOString(),
       },
     });
   }
   ```

2. **Type Safety:** Use TypeScript strict mode, no `any` types:

   ```typescript
   // Bad
   const token = (request as any).mcpToken;

   // Good
   interface MCPRequest extends FastifyRequest {
     mcpToken: MCPTokenPayload;
   }
   const token = (request as MCPRequest).mcpToken;
   ```

3. **Secrets Management:** Never commit JWT secrets to git. Use environment variables.

4. **Audit Logging:** Always log MCP requests, but fail-open if logging fails:

   ```typescript
   try {
     await logMCPAudit(...);
   } catch (error) {
     console.error('Audit logging failed:', error);
     // Don't throw - continue with MCP request
   }
   ```

5. **Rate Limiting:** Fail-open if Redis is unavailable (allow request):
   ```typescript
   try {
     // Rate limit logic
   } catch (error) {
     console.error('Rate limiter error:', error);
     // Fail open: allow request to proceed
   }
   ```

### Deployment Strategy

**[Source: docs/architecture.md#deployment-architecture]**

**Railway Environment Variables for Story 2.3:**

Set these in Railway dashboard for MCP service:

1. `MCP_JWT_SECRET`: Generate with `openssl rand -base64 32` (never commit to git)
2. `WEB_SERVICE_URL`: Set to web service URL (e.g., `https://jive-staging.up.railway.app`)
3. `DATABASE_URL`: Auto-injected by Railway Postgres (from Story 2.1)
4. `REDIS_URL`: Auto-injected by Railway Redis (from Story 2.1)

**JWT Secret Rotation:**

- Phase 1 (Story 2.3): Single shared secret (`HS256` algorithm)
- Phase 2 (Future): Asymmetric keys (`RS256` algorithm) with key rotation

**Security Hardening Checklist:**

- [ ] `MCP_JWT_SECRET` is minimum 32 bytes
- [ ] JWT expiry set to 1 hour (not configurable yet)
- [ ] Rate limiting enabled and tested
- [ ] Audit logging enabled for all MCP requests
- [ ] Health endpoint remains unauthenticated

### Security Considerations

**[Source: docs/architecture.md#security-requirements]**

**JWT Security Best Practices:**

1. **Algorithm Whitelist:** Only allow `HS256` or `RS256` (no `none` algorithm)

   ```typescript
   jwt.verify(token, secret, { algorithms: ['HS256'] });
   ```

2. **Clock Skew Tolerance:** Default 0 seconds (strict expiry checking)

   ```typescript
   jwt.verify(token, secret, { clockTolerance: 0 });
   ```

3. **Issuer/Audience Validation:** Always validate `iss` and `aud` claims

   ```typescript
   jwt.verify(token, secret, {
     issuer: process.env.WEB_SERVICE_URL,
     audience: 'mcp-server',
   });
   ```

4. **Token Revocation:** Not implemented in Story 2.3 (future: Redis blacklist)

**Rate Limiting Security:**

- **Purpose:** Prevent DoS attacks, brute-force attempts
- **Implementation:** Token bucket per actor (not per IP, to handle NAT/proxies)
- **Bypass:** None (even admins are rate-limited)

**Audit Logging Security:**

- **PII Protection:** Hash arguments with SHA-256 (don't store raw args)
- **Immutability:** Audit logs never deleted (retention policy TBD)
- **Forensics:** Capture IP address and User-Agent for incident response

### Relationship to Future Stories

**Story 2.3 Foundation for:**

- **Story 2.4 (MCP Tools):** Tools use `requireScope()` middleware to enforce authorization
- **Story 2.5 (Orchestrator):** Orchestrator publishes events, MCP tools subscribe via audit logs
- **Epic 3 (Agent Status):** Agent status updates logged via MCP audit trail
- **Phase 2 (Advanced Auth):** Token revocation, mutual-TLS, service account rotation

**Future Enhancements (Deferred):**

- Asymmetric JWT (RS256) with public/private key pairs
- Token revocation via Redis blacklist
- Mutual-TLS authentication for enterprise deployments
- OIDC integration for GitHub/Google SSO
- Scope inheritance and role-based templates

### Performance Considerations

**Rate Limiting Performance:**

- **Redis RTT:** Rate limiter adds ~1-2ms latency per request (Redis in same datacenter)
- **Token Bucket Efficiency:** O(1) time complexity, single Redis GET/SET per request
- **Fail-Open Strategy:** If Redis is down, allow requests (availability > rate limiting)

**Audit Logging Performance:**

- **Async Logging:** Use `prisma.mCPAuditLog.create()` without `await` (fire-and-forget)
- **Batch Logging:** Future optimization - batch audit logs every 1 second
- **Index Performance:** Audit log indexes on `projectId`, `actorId`, `tool` for fast queries

**JWT Verification Performance:**

- **HMAC Verification:** ~0.1ms per token (cryptographic operation)
- **Caching:** Future optimization - cache decoded tokens for 1 minute (reduce verification overhead)

## Change Log

| Date       | Version | Description                                 | Author |
| ---------- | ------- | ------------------------------------------- | ------ |
| 2025-10-15 | 1.0     | Story created for Epic 2 MCP authentication | SM Bob |

## Dev Agent Record

### Agent Model Used

_To be filled by Dev Agent_

### Debug Log References

_To be filled by Dev Agent_

### Completion Notes

_To be filled by Dev Agent_

### File List

_To be filled by Dev Agent_

## QA Results

_To be filled by QA Agent after implementation_
