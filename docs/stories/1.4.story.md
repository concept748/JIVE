# Story 1.4: BMAD Project Detection

## Status

Draft

## Story

**As a** System,
**I want** to detect if a directory is a valid BMAD project by checking for `.bmad-core/core-config.yaml`,
**so that** the orchestrator can identify legitimate projects from cloned repositories.

## Acceptance Criteria

1. `detectBMADProject(path)` function created in `lib/services/bmad-detector.ts`
2. Returns `true` if `.bmad-core/` directory exists with `core-config.yaml`
3. Parses `core-config.yaml` and extracts: `prdFile`, `architectureFile`, `devStoryLocation`, `qaLocation`
4. Returns project metadata object: `{ name, path, detected, config }`
5. Handles invalid YAML gracefully (returns `{ detected: false, error }`)
6. Unit tests covering: valid projects, missing `.bmad-core/`, malformed YAML (≥90% coverage)
7. TypeScript interface `ProjectConfig` matches architecture data model
8. All tests pass (`pnpm test`)

## Tasks / Subtasks

- [ ] **Task 1: Install YAML Parsing Dependency** (AC: 3)
  - [ ] Install js-yaml: `pnpm add js-yaml`
  - [ ] Install types: `pnpm add -D @types/js-yaml`
  - [ ] Verify package.json includes both dependencies
  - [ ] Run `pnpm type-check` to ensure no TypeScript errors

- [ ] **Task 2: Create TypeScript Interfaces** (AC: 4, 7)
  - [ ] Create `types/project.ts` file (if not exists)
  - [ ] Define `ProjectConfig` interface matching architecture data model:
    - [ ] `prdFile: string`
    - [ ] `prdVersion?: string`
    - [ ] `prdSharded: boolean`
    - [ ] `prdShardedLocation?: string`
    - [ ] `architectureFile: string`
    - [ ] `architectureVersion?: string`
    - [ ] `architectureSharded: boolean`
    - [ ] `architectureShardedLocation?: string`
    - [ ] `devStoryLocation: string`
    - [ ] `qaLocation: string`
    - [ ] `epicFilePattern?: string`
  - [ ] Define `ProjectMetadata` interface:
    - [ ] `name: string` (extracted from directory path)
    - [ ] `path: string` (full path to project root)
    - [ ] `detected: boolean`
    - [ ] `config?: ProjectConfig`
    - [ ] `error?: string` (for YAML parsing errors)
  - [ ] Export all interfaces

- [ ] **Task 3: Implement BMAD Detector Service** (AC: 1, 2, 3, 4, 5)
  - [ ] Create `lib/services/bmad-detector.ts` file
  - [ ] Import Node.js `fs` and `path` modules
  - [ ] Import `js-yaml` for YAML parsing
  - [ ] Import `ProjectConfig` and `ProjectMetadata` types
  - [ ] Implement `detectBMADProject(projectPath: string): Promise<ProjectMetadata>` function
    - [ ] Check if `.bmad-core/` directory exists at `projectPath`
    - [ ] If not exists, return `{ name, path, detected: false }`
    - [ ] Check if `core-config.yaml` exists in `.bmad-core/`
    - [ ] If not exists, return `{ name, path, detected: false, error: 'core-config.yaml not found' }`
    - [ ] Read `core-config.yaml` file contents
    - [ ] Parse YAML using js-yaml.load()
    - [ ] Wrap parsing in try-catch for malformed YAML
    - [ ] If YAML invalid, return `{ name, path, detected: false, error: 'Invalid YAML: <error message>' }`
    - [ ] Extract project name from directory path (last segment)
    - [ ] Validate required fields: `prdFile`, `architectureFile`, `devStoryLocation`, `qaLocation`
    - [ ] If required fields missing, return `{ detected: false, error: 'Missing required fields' }`
    - [ ] Return `{ name, path, detected: true, config: <parsed config> }`
  - [ ] Add JSDoc comments for function
  - [ ] Use TypeScript strict mode (no `any` types)

- [ ] **Task 4: Add Helper Functions** (AC: 5)
  - [ ] Implement `validateProjectConfig(config: unknown): config is ProjectConfig` type guard
    - [ ] Check if config is object
    - [ ] Validate required string fields exist
    - [ ] Validate boolean fields have correct types
    - [ ] Return true if valid, false otherwise
  - [ ] Implement `extractProjectName(projectPath: string): string` helper
    - [ ] Use `path.basename()` to get directory name
    - [ ] Return sanitized name (remove special chars if needed)
  - [ ] Add JSDoc comments for helpers

- [ ] **Task 5: Write Unit Tests for BMAD Detector** (AC: 6, 8)
  - [ ] Create `tests/unit/services/bmad-detector.test.ts`
  - [ ] Import `detectBMADProject` and test utilities (describe, test, expect, beforeEach, afterEach)
  - [ ] Import Node.js `fs`, `path`, and `os` for temp directory creation
  - [ ] Create test fixture helper:
    - [ ] `createTestProject(config: ProjectConfig): string` - creates temp directory with .bmad-core/core-config.yaml
    - [ ] `cleanupTestProject(path: string): void` - removes temp directory
  - [ ] Write test: `detects valid BMAD project with complete config`
    - [ ] Create test project with valid core-config.yaml
    - [ ] Call detectBMADProject()
    - [ ] Assert detected === true
    - [ ] Assert config matches expected values
    - [ ] Cleanup test project
  - [ ] Write test: `returns detected=false for missing .bmad-core directory`
    - [ ] Create temp directory without .bmad-core/
    - [ ] Call detectBMADProject()
    - [ ] Assert detected === false
    - [ ] Cleanup
  - [ ] Write test: `returns detected=false for missing core-config.yaml`
    - [ ] Create .bmad-core/ directory but no core-config.yaml
    - [ ] Call detectBMADProject()
    - [ ] Assert detected === false
    - [ ] Assert error message indicates missing file
    - [ ] Cleanup
  - [ ] Write test: `handles malformed YAML gracefully`
    - [ ] Create core-config.yaml with invalid YAML syntax (e.g., unclosed quotes)
    - [ ] Call detectBMADProject()
    - [ ] Assert detected === false
    - [ ] Assert error message contains "Invalid YAML"
    - [ ] Cleanup
  - [ ] Write test: `handles missing required fields`
    - [ ] Create core-config.yaml with partial config (missing prdFile)
    - [ ] Call detectBMADProject()
    - [ ] Assert detected === false
    - [ ] Assert error indicates missing fields
    - [ ] Cleanup
  - [ ] Write test: `extracts project name from path correctly`
    - [ ] Create test project with known directory name
    - [ ] Call detectBMADProject()
    - [ ] Assert name matches directory basename
    - [ ] Cleanup
  - [ ] Use beforeEach/afterEach for test isolation if needed
  - [ ] Run `pnpm test` and verify all tests pass
  - [ ] Run `pnpm test:coverage` and verify ≥90% coverage for bmad-detector.ts

- [ ] **Task 6: Integration with Existing Codebase** (AC: 7)
  - [ ] Verify `types/project.ts` exports match architecture data model
  - [ ] Compare with architecture.md lines 288-314 (Project and ProjectConfig interfaces)
  - [ ] Ensure consistency between code and architecture spec
  - [ ] Update types if any discrepancies found

- [ ] **Task 7: Verify Build and Type Safety** (AC: 8)
  - [ ] Run `pnpm type-check` to verify no TypeScript errors
  - [ ] Run `pnpm lint` to verify no linting errors
  - [ ] Run `pnpm build` to verify production build succeeds
  - [ ] Run `pnpm test` to verify all tests pass
  - [ ] Verify pre-commit hooks work (husky + lint-staged)

## Dev Notes

### Previous Story Insights

**[From Story 1.3 Dev Agent Record]**

Key learnings from Story 1.3 implementation:

1. **Testing Infrastructure Ready:** Story 1.3 established `tests/unit/services/` directory structure. Story 1.4 adds another unit test following the same pattern.

2. **Vitest Configuration:** Test runner configured with happy-dom environment, supports async operations (needed for file system operations in tests).

3. **TypeScript Strict Mode:** No `any` types allowed. YAML parsing results must be typed properly using type guards.

4. **Test Coverage Target:** ≥90% coverage established in Story 1.3, continuing in Story 1.4.

5. **File Naming Convention:** kebab-case for service files (`bmad-detector.ts`), matching existing pattern (`webhook-handler.ts`).

### Architecture Context

**[Source: docs/architecture.md#data-models]**

#### Project Interface (lines 288-314)

**Project Metadata Model:**

```typescript
interface Project {
  id: string;
  name: string;
  path: string;
  addedAt: Date;
  lastSeen: Date;
  config: ProjectConfig;
}

interface ProjectConfig {
  prdFile: string;
  prdVersion?: string;
  prdSharded: boolean;
  prdShardedLocation?: string;
  architectureFile: string;
  architectureVersion?: string;
  architectureSharded: boolean;
  architectureShardedLocation?: string;
  devStoryLocation: string;
  qaLocation: string;
  epicFilePattern?: string;
}
```

**Note:** Story 1.4 implements detection logic only. Full `Project` model (with `id`, `addedAt`, `lastSeen`) will be used when database integration is added in later stories. For now, `detectBMADProject()` returns a lightweight `ProjectMetadata` object.

**[Source: docs/architecture.md#components]**

#### BMAD Detector Component (Inferred from Architecture)

**Responsibility:** Detect if a directory is a valid BMAD project

**Technology:** Node.js `fs` API, js-yaml for YAML parsing

**Key Interfaces:**

- `detectBMADProject(path)` - Main detection function
- `validateProjectConfig(config)` - Type guard for ProjectConfig
- `extractProjectName(path)` - Helper to derive project name from path

**Usage Context:**

- Called by Orchestrator's RepoCloner after cloning repository
- Determines if cloned repo should be monitored
- Config extraction feeds into artifact scanning logic

**[Source: docs/architecture.md#unified-project-structure]**

#### BMAD Core Config File (lines 1660-1723)

**Expected Location in BMAD Projects:**

```
<project-root>/
├── .bmad-core/
│   ├── core-config.yaml      # THIS FILE is what Story 1.4 detects
│   ├── checklists/
│   ├── tasks/
│   └── templates/
├── docs/
│   ├── prd/
│   ├── architecture/
│   └── stories/
└── ...
```

**Example core-config.yaml (from JIVE project):**

```yaml
markdownExploder: true
qa:
  qaLocation: docs/qa
prd:
  prdFile: docs/prd.md
  prdVersion: v4
  prdSharded: true
  prdShardedLocation: docs/prd
  epicFilePattern: epic-{n}*.md
architecture:
  architectureFile: docs/architecture.md
  architectureVersion: v4
  architectureSharded: true
  architectureShardedLocation: docs/architecture
customTechnicalDocuments: null
devLoadAlwaysFiles:
  - docs/architecture/coding-standards.md
  - docs/architecture/tech-stack.md
  - docs/architecture/source-tree.md
devDebugLog: .ai/debug-log.md
devStoryLocation: docs/stories
slashPrefix: BMad
```

**Required Fields (Story 1.4 validates these):**

- `prd.prdFile` or `prdFile` (depending on structure)
- `architecture.architectureFile` or `architectureFile`
- `devStoryLocation`
- `qa.qaLocation` or `qaLocation`

### Testing Strategy

**[Source: docs/architecture.md#testing-strategy (lines 2109-2117, 2150-2173)]**

**Unit Test Requirements for Story 1.4:**

- **Framework:** Vitest (already configured in Story 1.3)
- **Coverage Target:** ≥90% for bmad-detector.ts
- **Test Isolation:** Use temp directories created in `os.tmpdir()` for each test
- **Cleanup:** Always cleanup temp directories in afterEach() to prevent disk bloat

**Test Case Categories:**

1. **Happy Path:** Valid BMAD project with complete config
2. **Missing Directory:** `.bmad-core/` doesn't exist
3. **Missing Config File:** `.bmad-core/` exists but no `core-config.yaml`
4. **Malformed YAML:** Invalid YAML syntax (unclosed quotes, invalid indentation)
5. **Incomplete Config:** Valid YAML but missing required fields
6. **Edge Cases:** Symlinks, permissions issues (optional for MVP)

**Example Test Structure:**

```typescript
// tests/unit/services/bmad-detector.test.ts
import { describe, test, expect, beforeEach, afterEach } from 'vitest';
import { detectBMADProject } from '@/lib/services/bmad-detector';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';

describe('BMADDetector', () => {
  let testProjectPath: string;

  beforeEach(() => {
    // Create temp directory for this test
    testProjectPath = fs.mkdtempSync(path.join(os.tmpdir(), 'bmad-test-'));
  });

  afterEach(() => {
    // Cleanup temp directory
    fs.rmSync(testProjectPath, { recursive: true, force: true });
  });

  test('detects valid BMAD project with complete config', async () => {
    // Setup: Create .bmad-core/core-config.yaml
    const bmadDir = path.join(testProjectPath, '.bmad-core');
    fs.mkdirSync(bmadDir);

    const config = {
      prdFile: 'docs/prd.md',
      architectureFile: 'docs/architecture.md',
      devStoryLocation: 'docs/stories',
      qaLocation: 'docs/qa',
      prdSharded: false,
      architectureSharded: false,
    };

    fs.writeFileSync(
      path.join(bmadDir, 'core-config.yaml'),
      JSON.stringify(config), // js-yaml can parse JSON too
    );

    // Execute
    const result = await detectBMADProject(testProjectPath);

    // Assert
    expect(result.detected).toBe(true);
    expect(result.config?.prdFile).toBe('docs/prd.md');
    expect(result.name).toBe(path.basename(testProjectPath));
  });

  test('returns detected=false for missing .bmad-core directory', async () => {
    // Execute (no setup - empty directory)
    const result = await detectBMADProject(testProjectPath);

    // Assert
    expect(result.detected).toBe(false);
    expect(result.config).toBeUndefined();
  });
});
```

### Tech Stack Additions

**[Source: docs/architecture.md#tech-stack (line 262)]**

**New Dependencies for Story 1.4:**

| Dependency     | Version | Purpose                                  | Rationale                                                    |
| -------------- | ------- | ---------------------------------------- | ------------------------------------------------------------ |
| js-yaml        | 4.1+    | Parse YAML front-matter and config files | Standard library for YAML parsing, used for core-config.yaml |
| @types/js-yaml | 4.0+    | TypeScript types for js-yaml             | Type safety for YAML parsing operations                      |

**Installation Commands:**

```bash
pnpm add js-yaml
pnpm add -D @types/js-yaml
```

**Note:** Architecture line 262 specifies `gray-matter` for markdown front-matter parsing (Story 1.6). Story 1.4 uses `js-yaml` directly since we're parsing standalone YAML files, not markdown with front-matter.

### File Locations

**[Source: docs/architecture.md#unified-project-structure (lines 1680-1687)]**

**New Files Created in Story 1.4:**

```
jive/
├── lib/
│   └── services/
│       ├── webhook-handler.ts         # From Story 1.3
│       └── bmad-detector.ts           # NEW - BMAD project detection
├── types/
│   ├── webhook.ts                     # From Story 1.3
│   └── project.ts                     # NEW - Project and ProjectConfig interfaces
├── tests/
│   └── unit/
│       └── services/
│           ├── webhook-handler.test.ts # From Story 1.3
│           └── bmad-detector.test.ts   # NEW - BMAD detector tests
└── package.json                       # Update with js-yaml dependencies
```

### Coding Standards

**[Source: docs/architecture.md#coding-standards (lines 2178-2189)]**

**Critical Rules for Story 1.4:**

1. **Type Safety:** No `any` types. Use type guards for YAML parsing results:

   ```typescript
   function validateProjectConfig(config: unknown): config is ProjectConfig {
     if (typeof config !== 'object' || config === null) return false;
     // ... validate required fields
     return true;
   }
   ```

2. **Error Handling:** All file system operations must use try-catch:

   ```typescript
   try {
     const fileContents = fs.readFileSync(configPath, 'utf-8');
     const config = yaml.load(fileContents);
     // ...
   } catch (error) {
     return { detected: false, error: error.message };
   }
   ```

3. **Async Operations:** Use async/await for consistency (even though fs operations can be sync):

   ```typescript
   export async function detectBMADProject(
     path: string,
   ): Promise<ProjectMetadata> {
     // ...
   }
   ```

4. **Import Paths:** Use `@/` alias:

   ```typescript
   import { ProjectConfig } from '@/types/project';
   ```

5. **File Naming:** kebab-case for files (`bmad-detector.ts`)

6. **Path Handling:** Always use `path.join()` for cross-platform compatibility:
   ```typescript
   const configPath = path.join(projectPath, '.bmad-core', 'core-config.yaml');
   ```

### Relationship to Architecture Components

**[Source: docs/architecture.md#components (lines 815-820)]**

**RepoCloner Component (Future Integration):**

```
RepoCloner (Story X.X - not yet implemented)
    ↓ clones repository to /tmp
    ↓ calls detectBMADProject() ← Story 1.4 implements this
    ↓ if detected=true
    ↓ proceeds to ArtifactScanner
    ↓ if detected=false
    ↓ skips repo (not a BMAD project)
```

**Story 1.4 Scope:**

- ✅ Implement `detectBMADProject()` function
- ✅ Parse `core-config.yaml`
- ✅ Return project metadata
- ❌ NOT implementing: RepoCloner (future story)
- ❌ NOT implementing: Database persistence (future story)
- ❌ NOT implementing: Webhook integration (future story)

**Expected Integration (Later Stories):**

```typescript
// Future orchestrator code (not Story 1.4)
import { detectBMADProject } from '@/lib/services/bmad-detector';
import { cloneRepo } from '@/lib/services/repo-cloner';

async function handleWebhookPush(repoUrl: string) {
  const clonePath = await cloneRepo(repoUrl); // Story X.X
  const project = await detectBMADProject(clonePath); // Story 1.4 ✅

  if (project.detected) {
    await scanArtifacts(project); // Story X.X
  } else {
    console.log('Not a BMAD project, skipping');
  }
}
```

### YAML Parsing Security Considerations

**[Source: docs/architecture.md#security-requirements]**

**YAML Parsing Best Practices:**

1. **Use `yaml.load()` not `yaml.loadAll()`** - core-config.yaml is a single document
2. **Set `schema: yaml.CORE_SCHEMA`** - prevents arbitrary code execution
3. **Validate parsed result** - use type guard to ensure expected structure
4. **Handle errors gracefully** - malformed YAML should not crash the service

**Safe YAML Parsing Example:**

```typescript
import * as yaml from 'js-yaml';

try {
  const fileContents = fs.readFileSync(configPath, 'utf-8');
  const parsed = yaml.load(fileContents, { schema: yaml.CORE_SCHEMA });

  if (!validateProjectConfig(parsed)) {
    return { detected: false, error: 'Invalid config structure' };
  }

  return { detected: true, config: parsed };
} catch (error) {
  return { detected: false, error: `YAML parsing failed: ${error.message}` };
}
```

### Data Model Alignment

**[Source: docs/architecture.md#data-models (lines 288-314)]**

**Mapping Between Story 1.4 and Architecture:**

| Story 1.4 Output        | Architecture `Project` Model  | Status                   |
| ----------------------- | ----------------------------- | ------------------------ |
| `name: string`          | `name: string`                | ✅ Match                 |
| `path: string`          | `path: string`                | ✅ Match                 |
| `detected: boolean`     | N/A (implicit in DB presence) | Story 1.4 only           |
| `config: ProjectConfig` | `config: ProjectConfig`       | ✅ Match                 |
| N/A                     | `id: string`                  | Added when DB integrated |
| N/A                     | `addedAt: Date`               | Added when DB integrated |
| N/A                     | `lastSeen: Date`              | Added when DB integrated |

**Note:** Story 1.4 returns a simplified `ProjectMetadata` object. When database integration is added (Story X.X), the full `Project` model will include `id`, `addedAt`, and `lastSeen` fields generated by the system.

### Edge Cases and Error Handling

**Test Coverage Requirements:**

1. **Valid Project:**
   - All required fields present
   - Optional fields may or may not be present
   - Both sharded and monolithic config structures

2. **Invalid Directory:**
   - Path doesn't exist
   - Path is a file, not a directory
   - Permission denied

3. **Missing .bmad-core:**
   - Directory exists but no `.bmad-core/` subdirectory

4. **Missing core-config.yaml:**
   - `.bmad-core/` exists but no `core-config.yaml` file

5. **Malformed YAML:**
   - Syntax errors (unclosed quotes, invalid indentation)
   - Invalid UTF-8 encoding
   - Empty file

6. **Invalid Config Structure:**
   - Valid YAML but not an object (e.g., array)
   - Missing required fields
   - Wrong type for fields (e.g., boolean where string expected)

7. **Symlinks and Special Files:**
   - `.bmad-core/` is a symlink (should follow link)
   - `core-config.yaml` is a symlink (should follow link)
   - (Optional for MVP - can defer to later stories)

### Performance Considerations

**File System Operations:**

Story 1.4 performs synchronous file system operations for simplicity:

- `fs.existsSync()` - Check directory/file existence
- `fs.readFileSync()` - Read core-config.yaml
- `yaml.load()` - Parse YAML

**Why Synchronous is OK for MVP:**

- Detection runs once per repo clone (infrequent)
- Small file size (core-config.yaml typically <1 KB)
- Simplifies error handling and testing
- No blocking HTTP requests (runs in background orchestrator)

**Future Optimization (if needed):**

- Use `fs.promises` for async operations
- Cache parsed configs (keyed by repo URL + commit SHA)
- Stream large YAML files (unlikely for core-config.yaml)

### Relationship to Future Stories

**Story 1.4 Foundation for:**

- **Story X.X (RepoCloner):** Will call `detectBMADProject()` after cloning repos
- **Story X.X (ArtifactScanner):** Uses `ProjectConfig` to locate PRD, architecture, stories
- **Story X.X (Database Integration):** Persist detected projects to PostgreSQL
- **Epic 2 (Multi-Project Portfolio):** Detect multiple projects from different repos

**Expected Call Flow (Future):**

```
GitHub Webhook → Orchestrator
    ↓
RepoCloner.cloneRepo(repoUrl)
    ↓
BMADDetector.detectBMADProject(clonePath) ← Story 1.4 ✅
    ↓
if detected=true → ArtifactScanner.scanRepo(project)
    ↓
PostgreSQL: INSERT INTO projects (name, path, config)
```

**Story 1.4 provides the detection logic; integration happens in later stories.**

## Change Log

| Date       | Version | Description                                                   | Author |
| ---------- | ------- | ------------------------------------------------------------- | ------ |
| 2025-10-15 | 1.0     | Story created from PRD Epic 1, aligned with Architecture v1.1 | SM Bob |

## Dev Agent Record

### Agent Model Used

_To be filled by Dev Agent_

### Debug Log References

_To be filled by Dev Agent_

### Completion Notes

_To be filled by Dev Agent_

### File List

_To be filled by Dev Agent_

## QA Results

_To be filled by QA Agent after implementation_
