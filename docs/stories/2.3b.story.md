# Story 2.3b: MCP Rate Limiting & Audit Logging

## Status

Draft

## Story

**As a** System Administrator,
**I want** MCP tool invocations rate-limited and audited,
**so that** I can prevent abuse and track all access to JIVE data.

## Acceptance Criteria

1. Rate limiting via Redis token bucket (60 requests/minute per client)
2. Audit logging to `mcp_audit_logs` table (actor, tool, scope, result, timestamp)
3. Rate-limited requests return 429 with `Retry-After` header
4. Audit logs capture all tool invocations (success and failure)
5. Redis failure fails open (allows request if Redis unavailable)
6. Unit tests for rate limiter and audit logger
7. Integration test: MCP tool call creates audit log entry
8. All tests pass (`pnpm test`)

## Tasks / Subtasks

- [ ] **Task 1: Create Rate Limiter** (AC: 1, 3, 5)
  - [ ] Create `lib/mcp/rate-limiter.ts` file
  - [ ] Import Redis client from `@/lib/db/redis`
  - [ ] Implement token bucket rate limiter:

    ```typescript
    import { redis } from '@/lib/db/redis';
    import { FastifyRequest, FastifyReply } from 'fastify';
    import { MCPTokenPayload } from './types/jwt';

    const MAX_REQUESTS = 60;
    const RATE_LIMIT_WINDOW = 60; // seconds

    export async function rateLimitMCP(
      request: FastifyRequest,
      reply: FastifyReply,
    ): Promise<void> {
      const token = (request as any).mcpToken as MCPTokenPayload;

      if (!token) {
        // No token = already rejected by auth middleware
        return;
      }

      const key = `rate_limit:mcp:${token.sub}`;

      try {
        const bucket = await redis.get(key);
        const now = Date.now();

        let tokens: number;
        let lastRefill: number;

        if (!bucket) {
          // First request - initialize bucket
          tokens = MAX_REQUESTS;
          lastRefill = now;
        } else {
          const data = JSON.parse(bucket);
          tokens = data.tokens;
          lastRefill = data.lastRefill;

          // Refill tokens based on elapsed time
          const elapsed = (now - lastRefill) / 1000; // seconds
          const refillAmount = Math.floor(
            elapsed * (MAX_REQUESTS / RATE_LIMIT_WINDOW),
          );
          tokens = Math.min(MAX_REQUESTS, tokens + refillAmount);
          lastRefill = now;
        }

        // Check if tokens available
        if (tokens < 1) {
          const retryAfter = Math.ceil(RATE_LIMIT_WINDOW / MAX_REQUESTS);
          return reply
            .status(429)
            .headers({ 'Retry-After': retryAfter.toString() })
            .send({
              error: {
                code: 'RATE_LIMITED',
                message: `Rate limit exceeded. Max ${MAX_REQUESTS} requests per ${RATE_LIMIT_WINDOW}s`,
                retryAfter,
                timestamp: new Date().toISOString(),
              },
            });
        }

        // Consume 1 token
        tokens -= 1;
        await redis.set(
          key,
          JSON.stringify({ tokens, lastRefill }),
          'EX',
          RATE_LIMIT_WINDOW,
        );
      } catch (error) {
        console.error('[Rate Limiter] Redis error:', error);
        // Fail open: allow request if Redis is down (avoid blocking legitimate users)
      }
    }
    ```

  - [ ] Export `rateLimitMCP` function

- [ ] **Task 2: Create Audit Logger** (AC: 2, 4)
  - [ ] Create `lib/mcp/audit-logger.ts` file
  - [ ] Import Prisma client and types
  - [ ] Implement `logMCPAudit()` function:

    ```typescript
    import { prisma } from '@/lib/db/prisma';
    import { MCPResult } from '@prisma/client';
    import { MCPTokenPayload } from './types/jwt';
    import crypto from 'crypto';

    export interface MCPAuditLogInput {
      projectId: string;
      token: MCPTokenPayload;
      tool: string;
      scope: string;
      args: any;
      result: MCPResult;
      errorMessage?: string;
      ipAddress: string;
      userAgent: string;
    }

    export async function logMCPAudit(input: MCPAuditLogInput): Promise<void> {
      // Hash args to prevent PII leakage in logs
      const argsHash = crypto
        .createHash('sha256')
        .update(JSON.stringify(input.args))
        .digest('hex');

      try {
        await prisma.mCPAuditLog.create({
          data: {
            projectId: input.projectId,
            actorType: input.token.actorType,
            actorId: input.token.sub,
            actorName: input.token.actorName,
            tool: input.tool,
            scope: input.scope,
            argsHash,
            result: input.result,
            errorMessage: input.errorMessage,
            ipAddress: input.ipAddress,
            userAgent: input.userAgent,
          },
        });

        console.log(
          `[Audit] ${input.token.actorName} invoked ${input.tool} → ${input.result}`,
        );
      } catch (error) {
        console.error('[Audit Logger] Failed to log MCP audit:', error);
        // Don't throw - audit logging failure shouldn't break MCP requests
      }
    }
    ```

  - [ ] Export `logMCPAudit` function and `MCPAuditLogInput` type

- [ ] **Task 3: Integrate Rate Limiter into MCP Server** (AC: 1, 3)
  - [ ] Open `lib/mcp/server.ts`
  - [ ] Import `rateLimitMCP` from rate-limiter
  - [ ] Add rate limiting hook after auth middleware:

    ```typescript
    import { rateLimitMCP } from './rate-limiter';

    // Add after verifyMCPToken hook
    app.addHook('preHandler', async (request, reply) => {
      if (request.url.startsWith('/mcp/') && request.url !== '/mcp/health') {
        await rateLimitMCP(request, reply);
      }
    });
    ```

  - [ ] Test locally: Make 61 rapid requests, verify 61st returns 429

- [ ] **Task 4: Integrate Audit Logger into MCP Server** (AC: 2, 4)
  - [ ] In `lib/mcp/server.ts`, import `logMCPAudit`
  - [ ] Note: Audit logging will be called from tool invocation endpoint (Story 2.4a)
  - [ ] Export `logMCPAudit` for use in POST /mcp/invoke handler
  - [ ] Audit log pattern:

    ```typescript
    // In POST /mcp/invoke handler (Story 2.4a will implement this)
    const result = await toolRegistry.invoke(tool, args, token, projectId);

    await logMCPAudit({
      projectId,
      token,
      tool,
      scope: toolDef.schema.scope,
      args,
      result: result.success ? MCPResult.SUCCESS : MCPResult.FAILURE,
      errorMessage: result.error?.message,
      ipAddress: request.ip,
      userAgent: request.headers['user-agent'] || 'unknown',
    });
    ```

- [ ] **Task 5: Write Unit Tests for Rate Limiter** (AC: 1, 3, 5, 6, 8)
  - [ ] Create `tests/unit/mcp/rate-limiter.test.ts`
  - [ ] Setup: Mock Redis client
  - [ ] Write test: `allows requests within rate limit`
    - [ ] Mock Redis to return null (first request)
    - [ ] Call rateLimitMCP() 60 times
    - [ ] Assert all succeed (no 429 response)
  - [ ] Write test: `blocks request exceeding rate limit`
    - [ ] Mock Redis bucket with 0 tokens
    - [ ] Call rateLimitMCP()
    - [ ] Assert reply.status(429) called
    - [ ] Assert error code is RATE_LIMITED
    - [ ] Assert Retry-After header set
  - [ ] Write test: `refills tokens over time`
    - [ ] Mock bucket with 0 tokens, lastRefill 30 seconds ago
    - [ ] Call rateLimitMCP()
    - [ ] Assert ~30 tokens refilled (allow request)
  - [ ] Write test: `fails open when Redis unavailable`
    - [ ] Mock Redis.get() to throw error
    - [ ] Call rateLimitMCP()
    - [ ] Assert request allowed (no 429)
    - [ ] Assert error logged to console

- [ ] **Task 6: Write Unit Tests for Audit Logger** (AC: 2, 4, 6, 8)
  - [ ] Create `tests/unit/mcp/audit-logger.test.ts`
  - [ ] Setup: Mock Prisma client
  - [ ] Write test: `creates audit log entry for successful tool invocation`
    - [ ] Mock prisma.mCPAuditLog.create()
    - [ ] Call logMCPAudit() with SUCCESS result
    - [ ] Assert create() called with correct data
    - [ ] Assert argsHash is SHA-256 hex string
  - [ ] Write test: `creates audit log entry for failed tool invocation`
    - [ ] Call logMCPAudit() with FAILURE result and errorMessage
    - [ ] Assert errorMessage persisted
  - [ ] Write test: `does not throw when Prisma fails`
    - [ ] Mock Prisma create() to throw error
    - [ ] Call logMCPAudit()
    - [ ] Assert function completes without throwing
    - [ ] Assert error logged to console

- [ ] **Task 7: Write Integration Test** (AC: 7, 8)
  - [ ] Create `tests/integration/mcp/rate-limit-audit.test.ts`
  - [ ] Setup: Start MCP server with test database and Redis
  - [ ] Write test: `rate limits after 60 requests`
    - [ ] Generate valid JWT
    - [ ] Make 61 requests to MCP endpoint
    - [ ] Assert first 60 succeed
    - [ ] Assert 61st returns 429 with Retry-After header
  - [ ] Write test: `audit log created for MCP tool invocation`
    - [ ] Generate valid JWT
    - [ ] Make request to MCP tool endpoint (requires Story 2.4a /mcp/invoke)
    - [ ] Query mcp_audit_logs table
    - [ ] Assert log entry exists with:
      - Correct actorId (token.sub)
      - Correct actorName (token.actorName)
      - Correct tool name
      - Correct scope
      - Correct result (SUCCESS or FAILURE)
      - Correct IP address and user agent

- [ ] **Task 8: Update MCP Server Startup Logging** (AC: 2)
  - [ ] In `lib/mcp/server.ts`, add startup log:
    ```typescript
    console.log('[MCP Server] Middleware enabled:');
    console.log('  ✓ JWT Authentication (all routes except /mcp/health)');
    console.log('  ✓ Rate Limiting (60 req/min per client)');
    console.log('  ✓ Audit Logging (all tool invocations)');
    ```

- [ ] **Task 9: Deploy to Railway** (AC: all)
  - [ ] Push Story 2.3b implementation to staging branch
  - [ ] Verify Railway deployment succeeds
  - [ ] Verify Redis connected (check Railway logs)
  - [ ] Test rate limiting on Railway:
    - Generate test JWT
    - Make 61 requests to `https://jive-mcp-staging.railway.app/mcp/tools`
    - Verify 61st returns 429
  - [ ] Query Railway Postgres for audit logs
  - [ ] Verify audit log entries created

- [ ] **Task 10: Verify All Tests Pass** (AC: 8)
  - [ ] Run unit tests: `pnpm test tests/unit/mcp/rate-limiter.test.ts`
  - [ ] Run unit tests: `pnpm test tests/unit/mcp/audit-logger.test.ts`
  - [ ] Run integration tests: `pnpm test tests/integration/mcp/rate-limit-audit.test.ts`
  - [ ] Verify test coverage >80% for rate-limiter.ts and audit-logger.ts
  - [ ] Run `pnpm type-check` to ensure no TypeScript errors
  - [ ] Run `pnpm lint` to ensure no linting errors

## Dev Notes

### Previous Story Insights

**[From Story 2.1, 2.2, 2.3a]**

Key context from previous stories:

1. **Database Setup:** Story 2.1 created `mcp_audit_logs` table with fields: projectId, actorType, actorId, actorName, tool, scope, argsHash, result, errorMessage, timestamp, ipAddress, userAgent.

2. **Redis Setup:** Story 2.1 created Redis client singleton at `lib/db/redis.ts`. Story 2.3b uses Redis for token bucket rate limiting.

3. **MCP Server:** Story 2.2 created Fastify HTTP server. Story 2.3b adds rate limiting and audit logging middleware.

4. **JWT Auth:** Story 2.3a created JWT verification middleware. Story 2.3b depends on `request.mcpToken` being populated by auth middleware.

5. **MCPTokenPayload:** Contains `sub` (actor ID), `actorType`, `actorName`, and `scopes` - all used by rate limiter and audit logger.

### Architecture Context

**[Source: docs/architecture.md#rate-limiting]**

#### Token Bucket Rate Limiting (lines 1730-1750)

**Algorithm:**

- **Bucket Capacity:** 60 tokens (max requests)
- **Refill Rate:** 60 tokens per 60 seconds = 1 token/second
- **Per-Client Key:** `rate_limit:mcp:{actorId}` (from JWT sub claim)
- **Redis TTL:** 60 seconds (auto-expire stale buckets)

**Redis Data Structure:**

```json
{
  "tokens": 45,
  "lastRefill": 1729996400000
}
```

**Refill Calculation:**

```typescript
const elapsed = (now - lastRefill) / 1000; // seconds since last refill
const refillAmount = Math.floor(elapsed * (MAX_REQUESTS / RATE_LIMIT_WINDOW));
const newTokens = Math.min(MAX_REQUESTS, currentTokens + refillAmount);
```

**429 Response Format:**

```json
{
  "error": {
    "code": "RATE_LIMITED",
    "message": "Rate limit exceeded. Max 60 requests per 60s",
    "retryAfter": 1,
    "timestamp": "2025-10-25T15:30:00Z"
  }
}
```

**Fail-Open Strategy:**

If Redis is unavailable (connection error, timeout), rate limiter fails open (allows request). This prevents Redis outage from blocking all MCP traffic. Error logged to console for monitoring.

**[Source: docs/architecture.md#audit-logging]**

#### MCP Audit Logging (lines 1755-1780)

**Audit Log Schema:**

```prisma
model MCPAuditLog {
  id           String    @id @default(uuid())
  projectId    String
  actorType    String    // 'ide_agent' | 'web_user' | 'system'
  actorId      String    // JWT sub claim
  actorName    String    // Human-readable name
  tool         String    // e.g., 'status.get'
  scope        String    // e.g., 'mcp:status.read'
  argsHash     String    // SHA-256 hash of args JSON
  result       MCPResult // SUCCESS | FAILURE | UNAUTHORIZED | RATE_LIMITED
  errorMessage String?   @db.Text
  timestamp    DateTime  @default(now())
  ipAddress    String
  userAgent    String    @db.Text

  project      Project   @relation(fields: [projectId], references: [id])

  @@index([projectId, timestamp])
  @@index([actorId, timestamp])
  @@index([tool, timestamp])
}

enum MCPResult {
  SUCCESS
  FAILURE
  UNAUTHORIZED
  RATE_LIMITED
}
```

**When to Log:**

- **Every MCP tool invocation** (success or failure)
- Logged AFTER tool execution completes
- Result is SUCCESS if tool returns `{ success: true }`, FAILURE otherwise

**Arguments Hashing:**

To prevent PII leakage in logs, args are hashed with SHA-256:

```typescript
const argsHash = crypto
  .createHash('sha256')
  .update(JSON.stringify(args))
  .digest('hex');
```

This allows log analysis without exposing sensitive data.

**Failure Handling:**

Audit logging uses try-catch with fail-silent strategy. If Prisma insert fails:

- Error logged to console
- MCP request proceeds normally (don't block user due to logging failure)

### Testing Strategy

**[Source: docs/architecture.md#testing-strategy]**

**Unit Test Requirements for Story 2.3b:**

- **Coverage Target:** >80% for rate-limiter.ts and audit-logger.ts
- **Mock Strategy:** Mock Redis client and Prisma client
- **Test Isolation:** Use vi.mock() for dependencies

**Mock Patterns:**

```typescript
// Mock Redis client
vi.mock('@/lib/db/redis', () => ({
  redis: {
    get: vi.fn(),
    set: vi.fn(),
  },
}));

// Mock Prisma client
vi.mock('@/lib/db/prisma', () => ({
  prisma: {
    mCPAuditLog: {
      create: vi.fn().mockResolvedValue({ id: 'test-log-id' }),
    },
  },
}));

// Mock crypto for predictable hashes (optional)
vi.mock('crypto', () => ({
  createHash: vi.fn(() => ({
    update: vi.fn().mockReturnThis(),
    digest: vi.fn(() => 'test-hash-abc123'),
  })),
}));
```

**Integration Test Requirements:**

- **Test Database:** Use test Postgres or in-memory SQLite
- **Test Redis:** Use redis-mock or separate Redis instance
- **Cleanup:** Clear rate limit keys and audit logs after each test

### Tech Stack

**Dependencies (Already Installed):**

- `ioredis` (from Story 2.1) - Redis client for rate limiting
- `@prisma/client` (from Story 2.1) - Database client for audit logs
- `crypto` (Node.js built-in) - SHA-256 hashing for args

**No New Dependencies Required**

### File Locations

**New Files Created in Story 2.3b:**

```
jive/
├── lib/
│   └── mcp/
│       ├── rate-limiter.ts                # NEW - Token bucket rate limiter
│       └── audit-logger.ts                # NEW - MCP audit logging
├── tests/
│   ├── unit/
│   │   └── mcp/
│   │       ├── rate-limiter.test.ts       # NEW - Rate limiter unit tests
│   │       └── audit-logger.test.ts       # NEW - Audit logger unit tests
│   └── integration/
│       └── mcp/
│           └── rate-limit-audit.test.ts   # NEW - Integration tests
└── lib/mcp/server.ts                      # UPDATE - Integrate rate limiter
```

### Coding Standards

**[Source: docs/architecture.md#coding-standards]**

**Critical Rules for Story 2.3b:**

1. **Fail-Open Pattern:** Rate limiter and audit logger must not block requests on failure:

   ```typescript
   try {
     // Rate limit or audit logic
   } catch (error) {
     console.error('Error:', error);
     // Continue - don't throw or block request
   }
   ```

2. **Async Error Handling:** Always use try-catch for async operations:

   ```typescript
   try {
     await redis.set(key, value);
   } catch (error) {
     console.error('[Rate Limiter] Redis error:', error);
   }
   ```

3. **Logging:** Use structured logging with context:

   ```typescript
   console.log(`[Audit] ${actorName} invoked ${tool} → ${result}`);
   console.error('[Rate Limiter] Redis error:', error);
   ```

4. **Type Safety:** Use Prisma-generated types:
   ```typescript
   import { MCPResult } from '@prisma/client';
   result: MCPResult.SUCCESS;
   ```

### Deployment Strategy

**[Source: docs/architecture.md#deployment-architecture]**

**Railway Deployment for Story 2.3b:**

- **No New Environment Variables** (uses existing Redis and Postgres connections)
- **Verification Steps:**
  1. Deploy to Railway (automatic on git push to staging)
  2. Check logs for "Middleware enabled" startup message
  3. Test rate limiting: 61 rapid requests → verify 429 response
  4. Query Postgres: `SELECT * FROM mcp_audit_logs ORDER BY timestamp DESC LIMIT 10`
  5. Verify audit logs created for test requests

**Monitoring:**

- **Rate Limit Metrics:** Count of 429 responses (future: expose via /mcp/metrics)
- **Audit Log Metrics:** Count of audit log entries per hour
- **Redis Health:** Monitor Redis connection errors in logs

### Relationship to Story 2.4a

**Story 2.3b Foundation for Story 2.4a:**

Story 2.3b provides observability infrastructure that Story 2.4a uses:

- `logMCPAudit()` function → called by `/mcp/invoke` endpoint after tool execution
- Rate limiting → prevents abuse of MCP tools
- Audit trail → tracks all tool invocations for security and debugging

**Story 2.4a Integration Points:**

```typescript
// In POST /mcp/invoke handler (Story 2.4a)
const result = await toolRegistry.invoke(tool, args, token, projectId);

await logMCPAudit({
  projectId,
  token,
  tool,
  scope: toolDef.schema.scope,
  args,
  result: result.success ? MCPResult.SUCCESS : MCPResult.FAILURE,
  errorMessage: result.error?.message,
  ipAddress: request.ip,
  userAgent: request.headers['user-agent'] || 'unknown',
});
```

## Change Log

| Date       | Version | Description                                                   | Author |
| ---------- | ------- | ------------------------------------------------------------- | ------ |
| 2025-10-25 | 1.0     | Story split from 2.3 for focused observability implementation | SM Bob |

## Dev Agent Record

### Agent Model Used

_To be filled by Dev Agent_

### Debug Log References

_To be filled by Dev Agent_

### Completion Notes

_To be filled by Dev Agent_

### File List

_To be filled by Dev Agent_

## QA Results

_To be filled by QA Agent after implementation_
